<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스튜디오 보라 _ 핀버튼 도안 제작기</title>
    <meta name="google-adsense-account" content="ca-pub-9005571517151133">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; padding: 0; overflow: hidden; touch-action: none; }
      * { box-sizing: border-box; }
      .transform-handle {
          width: 14px; height: 14px; background: white; border: 2px solid #3b82f6;
          border-radius: 50%; position: absolute; z-index: 10; 
          transform: translate(-50%, -50%);
          transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .transform-handle:hover { 
          background: #3b82f6; 
          transform: translate(-50%, -50%) scale(1.3);
          box-shadow: 0 0 12px rgba(59, 130, 246, 0.6);
      }
      @media (max-width: 768px) { .desktop-only { display: none !important; } }
      
      @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.95); }
          to { opacity: 1; transform: scale(1); }
      }
      
      @keyframes slideIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
      }
      
      .fade-in { animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
      .slide-in { animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
      
      .btn-hover {
          transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .btn-hover:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .btn-hover:active {
          transform: translateY(0);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
</style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const SIZES = [
          { inner: 25, outer: 35, label: '25mm - 35mm', type: 'circle' },
          { inner: 32, outer: 44, label: '32mm - 44mm', type: 'circle' },
          { inner: 44, outer: 54, label: '44mm - 54mm', type: 'circle', default: true },
          { inner: 58, outer: 69.5, label: '58mm - 69.5mm', type: 'circle' },
          { inner: 75, outer: 85, label: '75mm - 85mm', type: 'circle' },
          { inner: 50, outer: 61, label: '50mm - 61mm (네모)', type: 'square' },
          { inner: 54.287, outer: 70, label: '54mm - 70mm (하트)', type: 'heart' }
        ];

        const App = () => {
          const [selectedSize, setSelectedSize] = useState(SIZES.find(s => s.default));
          const [image, setImage] = useState(null);
          const [transform, setTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isDragging, setIsDragging] = useState(false);
          const [isResizing, setIsResizing] = useState(false);
          const [resizeHandle, setResizeHandle] = useState(null);
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [startTransform, setStartTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isMobile, setIsMobile] = useState(false);
          const [isInitialLoad, setIsInitialLoad] = useState(true);
          const fileInputRef = useRef(null);
          const imageRef = useRef(null);
          const SCALE_FACTOR = 4;

          useEffect(() => {
            const check = () => setIsMobile(window.innerWidth <= 768);
            check();
            window.addEventListener('resize', check);
            return () => window.removeEventListener('resize', check);
          }, []);

          const loadImage = (file) => {
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  const size = selectedSize.outer * 3;
                  const scale = Math.min(size * 2 / img.width, size * 2 / img.height);
                  setImage(e.target.result);
                  setTransform({ x: 0, y: 0, width: img.width * scale, height: img.height * scale });
                };
                img.src = e.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleMouseDown = (e) => {
            if (!image || e.target.classList.contains('transform-handle')) return;
            setIsDragging(true);
            setStartPos({ x: e.clientX - transform.x, y: e.clientY - transform.y });
          };

          const handleMouseMove = (e) => {
            if (isDragging) {
              setTransform(prev => ({ ...prev, x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
            } else if (isResizing && resizeHandle) {
              const dx = e.clientX - startPos.x;
              const dy = e.clientY - startPos.y;
              let newWidth = startTransform.width, newHeight = startTransform.height;

              if (['tl', 'tr', 'bl', 'br'].includes(resizeHandle)) {
                // 모서리: 비율 유지, 중심 고정
                const avgDelta = (Math.abs(dx) + Math.abs(dy)) / 2;
                const sign = (dx + dy) > 0 ? 1 : -1;
                const scale = 1 + (sign * avgDelta) / Math.max(startTransform.width, startTransform.height);
                newWidth = startTransform.width * scale;
                newHeight = startTransform.height * scale;
              } else if (resizeHandle === 't' || resizeHandle === 'b') {
                // 상하: 세로만 조절, 중심 고정
                const delta = resizeHandle === 'b' ? dy : -dy;
                newHeight = startTransform.height + delta * 2;
                newWidth = startTransform.width;
              } else if (resizeHandle === 'l' || resizeHandle === 'r') {
                // 좌우: 가로만 조절, 중심 고정
                const delta = resizeHandle === 'r' ? dx : -dx;
                newWidth = startTransform.width + delta * 2;
                newHeight = startTransform.height;
              }

              if (newWidth > 20 && newHeight > 20) {
                setTransform({ x: startTransform.x, y: startTransform.y, width: newWidth, height: newHeight });
              }
            }
          };

          const handleMouseUp = () => { setIsDragging(false); setIsResizing(false); setResizeHandle(null); };

          const handleResizeStart = (e, handle) => {
            e.stopPropagation();
            setIsResizing(true);
            setResizeHandle(handle);
            setStartPos({ x: e.clientX, y: e.clientY });
            setStartTransform({ ...transform });
          };

          const zoom = (factor) => {
            setTransform(prev => ({ ...prev, width: prev.width * factor, height: prev.height * factor }));
          };

          const moveImage = (dx, dy) => {
            setTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
          };

          const downloadImage = () => {
            if (!image || !imageRef.current) return;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const outerSize = selectedSize.outer * SCALE_FACTOR;
            const displaySize = selectedSize.outer * 3;
            const ratio = outerSize / displaySize;
            canvas.width = outerSize * 2;
            canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
            const cx = canvas.width / 2, cy = canvas.width / 2;

            ctx.save();
            ctx.translate(cx + transform.x * ratio, cy + transform.y * ratio);
            ctx.drawImage(imageRef.current, -transform.width * ratio / 2, -transform.height * ratio / 2, 
              transform.width * ratio, transform.height * ratio);
            ctx.restore();

            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              // 네모 실제 SVG path 적용 (다운로드, viewBox 200 기준)
              const s = (outerSize * 2) / 200;
              const ox = cx - 100 * s;
              const oy = cy - 100 * s;
              
              const x1 = 13.54 * s + ox;
              const y1 = 13.22 * s + oy;
              const w1 = 172.91 * s;
              const h1 = 172.91 * s;
              const rx1 = 28.35 * s;
              
              ctx.moveTo(x1 + rx1, y1);
              ctx.lineTo(x1 + w1 - rx1, y1);
              ctx.quadraticCurveTo(x1 + w1, y1, x1 + w1, y1 + rx1);
              ctx.lineTo(x1 + w1, y1 + h1 - rx1);
              ctx.quadraticCurveTo(x1 + w1, y1 + h1, x1 + w1 - rx1, y1 + h1);
              ctx.lineTo(x1 + rx1, y1 + h1);
              ctx.quadraticCurveTo(x1, y1 + h1, x1, y1 + h1 - rx1);
              ctx.lineTo(x1, y1 + rx1);
              ctx.quadraticCurveTo(x1, y1, x1 + rx1, y1);
              ctx.closePath();
            } else {
              // 하트 실제 SVG path 적용 (정중앙, 다운로드)
              const s = (outerSize * 2) / 226.78;
              const ox = cx - 113.39 * s;
              const oy = cy - 104.9 * s;
              ctx.moveTo(144.75*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(135*s+ox, 22.9*s+oy, 125.77*s+ox, 25.29*s+oy, 117.43*s+ox, 28.89*s+oy);
              ctx.bezierCurveTo(117.06*s+ox, 32.57*s+oy, 116.94*s+ox, 40.93*s+oy, 116.82*s+ox, 42.11*s+oy);
              ctx.bezierCurveTo(116.67*s+ox, 43.58*s+oy, 115.08*s+ox, 45.55*s+oy, 113.27*s+ox, 45.59*s+oy);
              ctx.bezierCurveTo(111.46*s+ox, 45.63*s+oy, 110.44*s+ox, 43.02*s+oy, 110.21*s+ox, 42.04*s+oy);
              ctx.bezierCurveTo(109.98*s+ox, 41.06*s+oy, 109.87*s+ox, 34.03*s+oy, 109.68*s+ox, 30.36*s+oy);
              ctx.bezierCurveTo(109.65*s+ox, 29.81*s+oy, 109.57*s+ox, 29.29*s+oy, 109.46*s+ox, 28.79*s+oy);
              ctx.bezierCurveTo(101.18*s+ox, 25.25*s+oy, 92.05*s+ox, 22.89*s+oy, 82.39*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(46.38*s+ox, 18.15*s+oy, 14.36*s+ox, 50.23*s+oy, 14.36*s+ox, 87.81*s+oy);
              ctx.bezierCurveTo(14.36*s+ox, 98.94*s+oy, 17.05*s+ox, 109.44*s+oy, 21.79*s+ox, 118.72*s+oy);
              ctx.bezierCurveTo(26.75*s+ox, 130.58*s+oy, 44.94*s+ox, 167.38*s+oy, 74.45*s+ox, 186.87*s+oy);
              ctx.bezierCurveTo(108.62*s+ox, 209.43*s+oy, 126.46*s+ox, 205.62*s+oy, 152.91*s+ox, 187.32*s+oy);
              ctx.bezierCurveTo(177.88*s+ox, 170.05*s+oy, 201.23*s+ox, 133.54*s+oy, 206.82*s+ox, 115.63*s+oy);
              ctx.bezierCurveTo(210.64*s+ox, 107.13*s+oy, 212.78*s+ox, 97.72*s+oy, 212.78*s+ox, 87.8*s+oy);
              ctx.bezierCurveTo(212.78*s+ox, 50.23*s+oy, 180.76*s+ox, 18.15*s+oy, 144.75*s+ox, 21.89*s+oy);
              ctx.closePath();
            }
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const s = (outerSize * 2) / 200;
              const ox = cx - 100 * s;
              const oy = cy - 100 * s;
              
              const x1 = 13.54 * s + ox;
              const y1 = 13.22 * s + oy;
              const w1 = 172.91 * s;
              const h1 = 172.91 * s;
              const rx1 = 28.35 * s;
              
              ctx.moveTo(x1 + rx1, y1);
              ctx.lineTo(x1 + w1 - rx1, y1);
              ctx.quadraticCurveTo(x1 + w1, y1, x1 + w1, y1 + rx1);
              ctx.lineTo(x1 + w1, y1 + h1 - rx1);
              ctx.quadraticCurveTo(x1 + w1, y1 + h1, x1 + w1 - rx1, y1 + h1);
              ctx.lineTo(x1 + rx1, y1 + h1);
              ctx.quadraticCurveTo(x1, y1 + h1, x1, y1 + h1 - rx1);
              ctx.lineTo(x1, y1 + rx1);
              ctx.quadraticCurveTo(x1, y1, x1 + rx1, y1);
              ctx.closePath();
            } else {
              const s = (outerSize * 2) / 226.78;
              const ox = cx - 113.39 * s;
              const oy = cy - 104.9 * s;
              ctx.moveTo(144.75*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(135*s+ox, 22.9*s+oy, 125.77*s+ox, 25.29*s+oy, 117.43*s+ox, 28.89*s+oy);
              ctx.bezierCurveTo(117.06*s+ox, 32.57*s+oy, 116.94*s+ox, 40.93*s+oy, 116.82*s+ox, 42.11*s+oy);
              ctx.bezierCurveTo(116.67*s+ox, 43.58*s+oy, 115.08*s+ox, 45.55*s+oy, 113.27*s+ox, 45.59*s+oy);
              ctx.bezierCurveTo(111.46*s+ox, 45.63*s+oy, 110.44*s+ox, 43.02*s+oy, 110.21*s+ox, 42.04*s+oy);
              ctx.bezierCurveTo(109.98*s+ox, 41.06*s+oy, 109.87*s+ox, 34.03*s+oy, 109.68*s+ox, 30.36*s+oy);
              ctx.bezierCurveTo(109.65*s+ox, 29.81*s+oy, 109.57*s+ox, 29.29*s+oy, 109.46*s+ox, 28.79*s+oy);
              ctx.bezierCurveTo(101.18*s+ox, 25.25*s+oy, 92.05*s+ox, 22.89*s+oy, 82.39*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(46.38*s+ox, 18.15*s+oy, 14.36*s+ox, 50.23*s+oy, 14.36*s+ox, 87.81*s+oy);
              ctx.bezierCurveTo(14.36*s+ox, 98.94*s+oy, 17.05*s+ox, 109.44*s+oy, 21.79*s+ox, 118.72*s+oy);
              ctx.bezierCurveTo(26.75*s+ox, 130.58*s+oy, 44.94*s+ox, 167.38*s+oy, 74.45*s+ox, 186.87*s+oy);
              ctx.bezierCurveTo(108.62*s+ox, 209.43*s+oy, 126.46*s+ox, 205.62*s+oy, 152.91*s+ox, 187.32*s+oy);
              ctx.bezierCurveTo(177.88*s+ox, 170.05*s+oy, 201.23*s+ox, 133.54*s+oy, 206.82*s+ox, 115.63*s+oy);
              ctx.bezierCurveTo(210.64*s+ox, 107.13*s+oy, 212.78*s+ox, 97.72*s+oy, 212.78*s+ox, 87.8*s+oy);
              ctx.bezierCurveTo(212.78*s+ox, 50.23*s+oy, 180.76*s+ox, 18.15*s+oy, 144.75*s+ox, 21.89*s+oy);
              ctx.closePath();
            }
            ctx.stroke();

            // 상단 선 (하트는 제외)
            if (selectedSize.type !== 'heart') {
              ctx.beginPath();
              ctx.moveTo(cx, 0);
              ctx.lineTo(cx, 2 * SCALE_FACTOR);
              ctx.stroke();
            }

            canvas.toBlob((blob) => {
              if (isMobile) {
                // 모바일: 새 탭에서 이미지 열기 (길게 눌러서 저장)
                canvas.toBlob((blob) => {
                  const url = URL.createObjectURL(blob);
                  const newWindow = window.open(url, '_blank');
                  if (!newWindow) {
                    // 팝업 차단된 경우 현재 탭에서 열기
                    window.location.href = url;
                  }
                }, 'image/png');
              } else {
                // 데스크톱: 기존 방식
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pin-button-${selectedSize.label}.png`;
                a.click();
                URL.revokeObjectURL(url);
              }
            }, 'image/png');
          };

          useEffect(() => {
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            return () => {
              document.removeEventListener('mouseup', handleMouseUp);
              document.removeEventListener('mousemove', handleMouseMove);
            };
          }, [isDragging, isResizing, startPos, startTransform, resizeHandle]);

          useEffect(() => {
              if (image) {
                const timer = setTimeout(() => {
                  setIsInitialLoad(false);
                }, 500);
                return () => clearTimeout(timer);
              }
            }, [image]);

          useEffect(() => {
            const container = document.querySelector('.touch-container');
            if (!container) return;

            let touchStartDist = 0;
            let touchStartTransform = { width: 0, height: 0 };
            let isTouching = false;

            const onTouchStart = (e) => {
              if (!image) return;
              
              if (e.touches.length === 1) {
                isTouching = true;
                const touch = e.touches[0];
                setStartPos({ 
                  x: touch.clientX - transform.x, 
                  y: touch.clientY - transform.y,
                  type: 'drag'
                });
              } else if (e.touches.length === 2) {
                e.preventDefault();
                isTouching = false;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                touchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                touchStartTransform = { width: transform.width, height: transform.height };
              }
            };

            const onTouchMove = (e) => {
              if (!image) return;
              
              if (e.touches.length === 1 && isTouching) {
                e.preventDefault();
                const touch = e.touches[0];
                setTransform(prev => ({ 
                  ...prev, 
                  x: touch.clientX - startPos.x, 
                  y: touch.clientY - startPos.y 
                }));
              } else if (e.touches.length === 2) {
                e.preventDefault();
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                const scale = dist / touchStartDist;
                
                setTransform(prev => ({ 
                  ...prev,
                  width: touchStartTransform.width * scale, 
                  height: touchStartTransform.height * scale 
                }));
              }
            };

            const onTouchEnd = () => {
              isTouching = false;
            };

            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onTouchEnd);

            return () => {
              container.removeEventListener('touchstart', onTouchStart);
              container.removeEventListener('touchmove', onTouchMove);
              container.removeEventListener('touchend', onTouchEnd);
            };
          }, [image, transform, startPos]);

          const size = isMobile ? selectedSize.outer * 2 : selectedSize.outer * 3;
          const innerSize = isMobile ? selectedSize.inner * 2 : selectedSize.inner * 3;

          const Shape = () => {
            const common = { display: 'block', touchAction: 'none', userSelect: 'none' };
            const clipId = 'clip';
            
            if (selectedSize.type === 'circle') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><circle cx={size} cy={size} r={size} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2} 
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}}/></>}
                  <circle cx={size} cy={size} r={size} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <circle cx={size} cy={size} r={innerSize} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else if (selectedSize.type === 'square') {
              const r = size * 0.15, ir = innerSize * 0.15;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><rect x={0} y={0} width={size * 2} height={size * 2} rx={r} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}} /></>}
                  <rect x={0} y={0} width={size * 2} height={size * 2} rx={r} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}} />
                  <rect x={size - innerSize} y={size - innerSize} width={innerSize * 2} height={innerSize * 2} rx={ir} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else {
              // 하트 path를 실제 SVG 값으로 변환 (정중앙 배치)
              const scale = (size * 2) / 226.78;
              const centerX = size;
              const centerY = size;
              const svgCenterX = 113.39;
              const svgCenterY = 104.9; // 하트 SVG의 실제 중심점
              const offsetX = centerX - svgCenterX * scale;
              const offsetY = centerY - svgCenterY * scale;
              
              const outerPath = `M${144.75*scale+offsetX},${21.89*scale+offsetY}c${-9.75*scale},${1.01*scale},${-18.98*scale},${3.4*scale},${-27.32*scale},${7*scale},${-0.37*scale},${3.68*scale},${-0.49*scale},${12.04*scale},${-0.61*scale},${13.22*scale},${-0.15*scale},${1.47*scale},${-1.74*scale},${3.44*scale},${-3.55*scale},${3.48*scale},${-1.81*scale},${0.04*scale},${-2.83*scale},${-2.57*scale},${-3.06*scale},${-3.55*scale},${-0.23*scale},${-0.98*scale},${-0.34*scale},${-8.01*scale},${-0.53*scale},${-11.68*scale},${-0.03*scale},${-0.55*scale},${-0.11*scale},${-1.07*scale},${-0.22*scale},${-1.57*scale},${-8.28*scale},${-3.54*scale},${-17.41*scale},${-5.9*scale},${-27.07*scale},${-6.9*scale}C${46.38*scale+offsetX},${18.15*scale+offsetY},${14.36*scale+offsetX},${50.23*scale+offsetY},${14.36*scale+offsetX},${87.81*scale+offsetY}c0,${11.13*scale},${2.69*scale},${21.63*scale},${7.43*scale},${30.91*scale},${4.96*scale},${11.86*scale},${23.15*scale},${48.66*scale},${52.66*scale},${68.15*scale},${34.17*scale},${22.56*scale},${52.01*scale},${18.75*scale},${78.46*scale},${0.45*scale},${24.97*scale},${-17.27*scale},${48.32*scale},${-53.78*scale},${53.91*scale},${-71.69*scale},${3.82*scale},${-8.5*scale},${5.96*scale},${-17.91*scale},${5.96*scale},${-27.83*scale},0,${-37.57*scale},${-32.02*scale},${-69.65*scale},${-68.03*scale},${-65.91*scale}Z`;
              
              const innerPath = `M${141.65*scale+offsetX},${42.21*scale+offsetY}c${-6.25*scale},${0.65*scale},${-16.7*scale},${4.38*scale},${-23.22*scale},${7.08*scale},${-1.33*scale},${0.55*scale},${-2.75*scale},${0.87*scale},${-4.83*scale},${0.96*scale},${-2.15*scale},${-0.09*scale},${-3.56*scale},${-0.41*scale},${-4.89*scale},${-0.96*scale},${-6.51*scale},${-2.7*scale},${-16.97*scale},${-6.44*scale},${-23.22*scale},${-7.08*scale},${-26.23*scale},${-2.72*scale},${-48.86*scale},${17.43*scale},${-48.86*scale},${44.81*scale},0,${12.39*scale},${5.63*scale},${24.2*scale},${8.41*scale},${30.39*scale},${5.35*scale},${14.16*scale},${20.67*scale},${33.47*scale},${37.63*scale},${47.67*scale},${14.76*scale},${12.36*scale},${23.17*scale},${17.05*scale},${30.93*scale},${17*scale}h0s0,0,0,0c0,0,0,0,0,0h0c${7.69*scale},${0.05*scale},${16.1*scale},${-4.64*scale},${30.87*scale},${-17*scale},${16.96*scale},${-14.2*scale},${32.28*scale},${-33.52*scale},${37.63*scale},${-47.67*scale},${2.78*scale},${-6.19*scale},${8.41*scale},${-18*scale},${8.41*scale},${-30.39*scale},0,${-27.37*scale},${-22.63*scale},${-47.53*scale},${-48.86*scale},${-44.81*scale}Z`;
              
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><path d={outerPath} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}}/></>}
                  <path d={outerPath} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <path d={innerPath} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            }
          };

          return (
            <div className={`flex ${isMobile ? 'flex-col' : ''} h-screen bg-gray-100`}>
              <div className={`${isMobile ? 'flex-1 order-2' : 'flex-1'} flex items-center justify-center p-4 overflow-auto`}>
              <div className={`relative bg-white rounded-lg shadow-lg p-12 touch-container ${isInitialLoad ? "fade-in" : ""}`}
                onDrop={(e) => { e.preventDefault(); loadImage(e.dataTransfer.files[0]); }} 
                onDragOver={(e) => e.preventDefault()} 
                onMouseDown={handleMouseDown}
                style={{ touchAction: 'none' }}>
                  <div style={{ position: 'relative' }}>
                    <Shape />
                    {image && !isMobile && ['tl','tr','bl','br','t','b','l','r'].map(h => {
                      const cursors = {tl:'nwse-resize',tr:'nesw-resize',bl:'nesw-resize',br:'nwse-resize',t:'ns-resize',b:'ns-resize',l:'ew-resize',r:'ew-resize'};
                      const pos = {
                        tl: [transform.x - transform.width / 2, transform.y - transform.height / 2],
                        tr: [transform.x + transform.width / 2, transform.y - transform.height / 2],
                        bl: [transform.x - transform.width / 2, transform.y + transform.height / 2],
                        br: [transform.x + transform.width / 2, transform.y + transform.height / 2],
                        t: [transform.x, transform.y - transform.height / 2],
                        b: [transform.x, transform.y + transform.height / 2],
                        l: [transform.x - transform.width / 2, transform.y],
                        r: [transform.x + transform.width / 2, transform.y]
                      };
                      return <div key={h} className="transform-handle" 
                        style={{ left: size + pos[h][0], top: size + pos[h][1], cursor: cursors[h] }} 
                        onMouseDown={(e) => handleResizeStart(e, h)} />;
                    })}
                  </div>
                </div>
              </div>

              <div className={`${isMobile ? 'order-1 w-full' : 'w-64'} bg-white shadow-lg p-4 flex ${isMobile ? 'flex-row flex-wrap' : 'flex-col'} gap-3 overflow-auto slide-in`}>
                <h2 className={`${isMobile ? 'w-full' : ''} text-lg font-bold mb-2`}>스튜디오 보라</h2>
                
                {!isMobile ? SIZES.map((s, i) => (
                  <button key={i} onClick={() => { setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 }); }}
                    className={`px-4 py-2 rounded-lg text-sm font-medium text-left ${selectedSize.label === s.label ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'} btn-hover`}>
                    {s.label}
                  </button>
                )) : (
                  <select value={selectedSize.label} onChange={(e) => {
                    const s = SIZES.find(sz => sz.label === e.target.value);
                    setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 });
                  }} className="flex-1 px-3 py-2 rounded-lg bg-blue-500 text-white text-sm font-medium">
                    {SIZES.map((s, i) => <option key={i} value={s.label}>{s.label}</option>)}
                  </select>
                )}

                <button onClick={() => fileInputRef.current?.click()}
                  className={`${isMobile ? 'flex-1' : 'mt-4'} flex items-center justify-center gap-2 px-4 py-2 bg-green-500 text-white text-sm rounded-lg hover:bg-green-600 btn-hover`}>
                  ⬆ {isMobile ? '업로드' : '사진 업로드'}
                </button>

                {image && (
                  <>
                    <div className={`flex gap-2 ${isMobile ? 'w-full' : ''} slide-in`}>
                      <button onClick={() => zoom(0.9)} className="flex-1 px-3 py-2 bg-gray-500 text-white text-lg rounded-lg hover:bg-gray-600 btn-hover">−</button>
                      <button onClick={() => zoom(1.1)} className="flex-1 px-3 py-2 bg-gray-500 text-white text-lg rounded-lg hover:bg-gray-600 btn-hover">+</button>
                    </div>
                    
                    <div className={`${isMobile ? 'w-full' : ''}`}>
                      <div className="grid grid-cols-3 gap-1">
                        <div></div>
                        <button onClick={() => moveImage(0, -10)} className="px-3 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 btn-hover">↑</button>
                        <div></div>
                        <button onClick={() => moveImage(-10, 0)} className="px-3 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 btn-hover">←</button>
                        <div></div>
                        <button onClick={() => moveImage(10, 0)} className="px-3 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 btn-hover">→</button>
                        <div></div>
                        <button onClick={() => moveImage(0, 10)} className="px-3 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 btn-hover">↓</button>
                        <div></div>
                      </div>
                    </div>
                  </>
                )}

                <button onClick={downloadImage} disabled={!image}
                  className={`${isMobile ? 'w-full' : ''} flex items-center justify-center gap-2 px-4 py-2 text-sm rounded-lg ${image ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500'} btn-hover`}>
                  ⬇ {isMobile ? '다운' : 'PNG 다운로드'}
                </button>

                {image && !isMobile && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg text-xs text-gray-700">
                    <p className="font-bold mb-1">사용법:</p>
                    <p>• 드래그: 이동</p>
                    <p>• 핸들: 크기조절</p>
                    <p>• +/- : 확대축소</p>
                    <p>• 화살표: 미세조정</p>
                  </div>
                )}
              </div>

              <input ref={fileInputRef} type="file" accept="image/*" onChange={(e) => loadImage(e.target.files?.[0])} className="hidden" />
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>