<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>핀버튼 도안 제작</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        .transform-handle {
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
        }
        .transform-handle:hover {
            background: #3b82f6;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const SIZES = [
          { inner: 25, outer: 35, label: '25mm - 35mm', type: 'circle' },
          { inner: 32, outer: 44, label: '32mm - 44mm', type: 'circle' },
          { inner: 44, outer: 54, label: '44mm - 54mm', type: 'circle', default: true },
          { inner: 58, outer: 69.5, label: '58mm - 69.5mm', type: 'circle' },
          { inner: 75, outer: 85, label: '75mm - 85mm', type: 'circle' },
          { inner: 50, outer: 61, label: '50mm - 61mm (네모)', type: 'square' },
          { inner: 54.287, outer: 70, label: '54mm - 70mm (하트)', type: 'heart' }
        ];

        const App = () => {
          const [selectedSize, setSelectedSize] = useState(SIZES.find(s => s.default));
          const [image, setImage] = useState(null);
          const [transform, setTransform] = useState({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
          const [isDragging, setIsDragging] = useState(false);
          const [isTransforming, setIsTransforming] = useState(false);
          const [dragHandle, setDragHandle] = useState(null);
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [startTransform, setStartTransform] = useState({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
          
          const fileInputRef = useRef(null);
          const imageRef = useRef(null);
          const containerRef = useRef(null);

          const SCALE_FACTOR = 4;

          const loadImage = (file) => {
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  setImage(e.target.result);
                  setTransform({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
                };
                img.src = e.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleDrop = (e) => {
            e.preventDefault();
            loadImage(e.dataTransfer.files[0]);
          };

          const handleFileSelect = (e) => {
            loadImage(e.target.files?.[0]);
          };

          const handleMouseDown = (e) => {
            if (!image || e.target.classList.contains('transform-handle')) return;
            setIsDragging(true);
            setStartPos({ x: e.clientX - transform.x, y: e.clientY - transform.y });
          };

          const handleMouseMove = (e) => {
            if (isDragging) {
              setTransform(prev => ({ ...prev, x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
            } else if (isTransforming) {
              const dx = e.clientX - startPos.x;
              const dy = e.clientY - startPos.y;
              const factor = 0.01;
              
              let newScaleX = startTransform.scaleX;
              let newScaleY = startTransform.scaleY;
              
              if (dragHandle === 'tl' || dragHandle === 'tr' || dragHandle === 'bl' || dragHandle === 'br') {
                const avg = (dx + dy) / 2;
                newScaleX = Math.max(0.1, Math.min(5, startTransform.scaleX * (1 + avg * factor)));
                newScaleY = Math.max(0.1, Math.min(5, startTransform.scaleY * (1 + avg * factor)));
              } else if (dragHandle === 't' || dragHandle === 'b') {
                const mult = dragHandle === 'b' ? 1 : -1;
                newScaleY = Math.max(0.1, Math.min(5, startTransform.scaleY * (1 + dy * factor * mult)));
                newScaleX = startTransform.scaleX;
              } else if (dragHandle === 'l' || dragHandle === 'r') {
                const mult = dragHandle === 'r' ? 1 : -1;
                newScaleX = Math.max(0.1, Math.min(5, startTransform.scaleX * (1 + dx * factor * mult)));
                newScaleY = startTransform.scaleY;
              }
              
              setTransform(prev => ({ ...prev, scaleX: newScaleX, scaleY: newScaleY }));
            }
          };

          const handleMouseUp = () => {
            setIsDragging(false);
            setIsTransforming(false);
            setDragHandle(null);
          };

          const handleTransformStart = (e, handle) => {
            e.stopPropagation();
            setIsTransforming(true);
            setDragHandle(handle);
            setStartPos({ x: e.clientX, y: e.clientY });
            setStartTransform({ ...transform });
          };

          const handleWheel = (e) => {
            if (!image) return;
            e.preventDefault();
            const delta = -e.deltaY * 0.001;
            setTransform(prev => ({
              ...prev,
              scaleX: Math.max(0.1, Math.min(5, prev.scaleX + delta)),
              scaleY: Math.max(0.1, Math.min(5, prev.scaleY + delta))
            }));
          };

          const zoomIn = () => {
            setTransform(prev => ({
              ...prev,
              scaleX: Math.min(5, prev.scaleX + 0.1),
              scaleY: Math.min(5, prev.scaleY + 0.1)
            }));
          };

          const zoomOut = () => {
            setTransform(prev => ({
              ...prev,
              scaleX: Math.max(0.1, prev.scaleX - 0.1),
              scaleY: Math.max(0.1, prev.scaleY - 0.1)
            }));
          };

          const downloadImage = () => {
            if (!image || !imageRef.current) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const outerSize = selectedSize.outer * SCALE_FACTOR;
            const displaySize = selectedSize.outer * 3;
            const ratio = outerSize / displaySize;

            canvas.width = outerSize * 2;
            canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
            const cx = canvas.width / 2;
            const cy = canvas.width / 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.translate(transform.x * ratio, transform.y * ratio);
            ctx.scale(transform.scaleX, transform.scaleY);
            const w = imageRef.current.width * ratio;
            const h = imageRef.current.height * ratio;
            ctx.drawImage(imageRef.current, -w / 2, -h / 2, w, h);
            ctx.restore();

            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const r = outerSize * 0.15;
              ctx.moveTo(cx - outerSize + r, cy - outerSize);
              ctx.lineTo(cx + outerSize - r, cy - outerSize);
              ctx.quadraticCurveTo(cx + outerSize, cy - outerSize, cx + outerSize, cy - outerSize + r);
              ctx.lineTo(cx + outerSize, cy + outerSize - r);
              ctx.quadraticCurveTo(cx + outerSize, cy + outerSize, cx + outerSize - r, cy + outerSize);
              ctx.lineTo(cx - outerSize + r, cy + outerSize);
              ctx.quadraticCurveTo(cx - outerSize, cy + outerSize, cx - outerSize, cy + outerSize - r);
              ctx.lineTo(cx - outerSize, cy - outerSize + r);
              ctx.quadraticCurveTo(cx - outerSize, cy - outerSize, cx - outerSize + r, cy - outerSize);
              ctx.closePath();
            } else if (selectedSize.type === 'heart') {
              ctx.moveTo(cx, cy - outerSize * 0.25);
              ctx.bezierCurveTo(cx - outerSize * 0.55, cy - outerSize * 0.85, cx - outerSize * 1.15, cy + outerSize * 0.05, cx, cy + outerSize * 0.95);
              ctx.bezierCurveTo(cx + outerSize * 1.15, cy + outerSize * 0.05, cx + outerSize * 0.55, cy - outerSize * 0.85, cx, cy - outerSize * 0.25);
              ctx.closePath();
            }
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const r = outerSize * 0.15;
              ctx.moveTo(cx - outerSize + r, cy - outerSize);
              ctx.lineTo(cx + outerSize - r, cy - outerSize);
              ctx.quadraticCurveTo(cx + outerSize, cy - outerSize, cx + outerSize, cy - outerSize + r);
              ctx.lineTo(cx + outerSize, cy + outerSize - r);
              ctx.quadraticCurveTo(cx + outerSize, cy + outerSize, cx + outerSize - r, cy + outerSize);
              ctx.lineTo(cx - outerSize + r, cy + outerSize);
              ctx.quadraticCurveTo(cx - outerSize, cy + outerSize, cx - outerSize, cy + outerSize - r);
              ctx.lineTo(cx - outerSize, cy - outerSize + r);
              ctx.quadraticCurveTo(cx - outerSize, cy - outerSize, cx - outerSize + r, cy - outerSize);
              ctx.closePath();
            } else if (selectedSize.type === 'heart') {
              ctx.moveTo(cx, cy - outerSize * 0.25);
              ctx.bezierCurveTo(cx - outerSize * 0.55, cy - outerSize * 0.85, cx - outerSize * 1.15, cy + outerSize * 0.05, cx, cy + outerSize * 0.95);
              ctx.bezierCurveTo(cx + outerSize * 1.15, cy + outerSize * 0.05, cx + outerSize * 0.55, cy - outerSize * 0.85, cx, cy - outerSize * 0.25);
              ctx.closePath();
            }
            ctx.stroke();

            ctx.beginPath();
            if (selectedSize.type === 'heart') {
              const nw = 6 * SCALE_FACTOR;
              const nd = 2 * SCALE_FACTOR;
              ctx.moveTo(cx - nw / 2, 0);
              ctx.lineTo(cx - nw / 2, nd);
              ctx.quadraticCurveTo(cx, nd * 1.5, cx + nw / 2, nd);
              ctx.lineTo(cx + nw / 2, 0);
            } else {
              ctx.moveTo(cx, 0);
              ctx.lineTo(cx, 2 * SCALE_FACTOR);
            }
            ctx.stroke();

            canvas.toBlob((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `pin-button-${selectedSize.label}.png`;
              a.click();
              URL.revokeObjectURL(url);
            }, 'image/png');
          };

          useEffect(() => {
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            return () => {
              document.removeEventListener('mouseup', handleMouseUp);
              document.removeEventListener('mousemove', handleMouseMove);
            };
          }, [isDragging, isTransforming, startPos, startTransform, dragHandle]);

          const size = selectedSize.outer * 3;
          const innerSize = selectedSize.inner * 3;
          const imgW = (imageRef.current?.width || 0) * transform.scaleX;
          const imgH = (imageRef.current?.height || 0) * transform.scaleY;

          const renderShape = () => {
            if (selectedSize.type === 'circle') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="clip">
                          <circle cx={size} cy={size} r={size} />
                        </clipPath>
                      </defs>
                      <image href={image} x={size + transform.x - imgW / 2} y={size + transform.y - imgH / 2} 
                        width={imgW} height={imgH} clipPath="url(#clip)" style={{ pointerEvents: 'none' }} />
                    </g>
                  )}
                  <circle cx={size} cy={size} r={size} fill="none" stroke="#000" strokeWidth="2" />
                  <circle cx={size} cy={size} r={innerSize} fill="none" stroke="#f00" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && (
                    <g onClick={() => fileInputRef.current?.click()} style={{ cursor: 'pointer' }}>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text>
                    </g>
                  )}
                </svg>
              );
            } else if (selectedSize.type === 'square') {
              const r = size * 0.15;
              const ir = innerSize * 0.82;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="clip">
                          <rect x={0} y={0} width={size * 2} height={size * 2} rx={r} />
                        </clipPath>
                      </defs>
                      <image href={image} x={size + transform.x - imgW / 2} y={size + transform.y - imgH / 2}
                        width={imgW} height={imgH} clipPath="url(#clip)" style={{ pointerEvents: 'none' }} />
                    </g>
                  )}
                  <rect x={0} y={0} width={size * 2} height={size * 2} rx={r} fill="none" stroke="#000" strokeWidth="2" />
                  <rect x={size - innerSize} y={size - innerSize} width={innerSize * 2} height={innerSize * 2} rx={ir} fill="none" stroke="#f00" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && (
                    <g onClick={() => fileInputRef.current?.click()} style={{ cursor: 'pointer' }}>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text>
                    </g>
                  )}
                </svg>
              );
            } else {
              const heartPath = `M ${size},${size * 0.75} C ${size * 0.45},${size * 0.15} ${size * -0.15},${size * 1.05} ${size},${size * 1.95} C ${size * 2.15},${size * 1.05} ${size * 1.55},${size * 0.15} ${size},${size * 0.75} Z`;
              const innerPath = `M ${size},${size * 0.815} C ${size * 0.485},${size * 0.255} ${size * -0.06},${size * 1.085} ${size},${size * 1.835} C ${size * 2.06},${size * 1.085} ${size * 1.515},${size * 0.255} ${size},${size * 0.815} Z`;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="clip">
                          <path d={heartPath} />
                        </clipPath>
                      </defs>
                      <image href={image} x={size + transform.x - imgW / 2} y={size + transform.y - imgH / 2}
                        width={imgW} height={imgH} clipPath="url(#clip)" style={{ pointerEvents: 'none' }} />
                    </g>
                  )}
                  <path d={heartPath} fill="none" stroke="#000" strokeWidth="2" />
                  <path d={innerPath} fill="none" stroke="#f00" strokeWidth="2" />
                  <path d={`M ${size - 6},0 L ${size - 6},6 Q ${size},9 ${size + 6},6 L ${size + 6},0`} fill="none" stroke="#000" strokeWidth="1" />
                  {!image && (
                    <g onClick={() => fileInputRef.current?.click()} style={{ cursor: 'pointer' }}>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text>
                    </g>
                  )}
                </svg>
              );
            }
          };

          return (
            <div className="flex h-screen bg-gray-100">
              <div className="flex-1 flex items-center justify-center p-8">
                <div ref={containerRef} className="relative bg-white rounded-lg shadow-lg p-12" style={{ width: 'fit-content' }}
                  onDrop={handleDrop} onDragOver={(e) => e.preventDefault()} onMouseDown={handleMouseDown} onWheel={handleWheel}>
                  <div style={{ position: 'relative' }}>
                    {renderShape()}
                    {image && (
                      <>
                        <div className="transform-handle" style={{ left: size + transform.x - imgW / 2 - 6, top: size + transform.y - imgH / 2 - 6, cursor: 'nwse-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'tl')} />
                        <div className="transform-handle" style={{ left: size + transform.x + imgW / 2 - 6, top: size + transform.y - imgH / 2 - 6, cursor: 'nesw-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'tr')} />
                        <div className="transform-handle" style={{ left: size + transform.x - imgW / 2 - 6, top: size + transform.y + imgH / 2 - 6, cursor: 'nesw-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'bl')} />
                        <div className="transform-handle" style={{ left: size + transform.x + imgW / 2 - 6, top: size + transform.y + imgH / 2 - 6, cursor: 'nwse-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'br')} />
                        <div className="transform-handle" style={{ left: size + transform.x - 6, top: size + transform.y - imgH / 2 - 6, cursor: 'ns-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 't')} />
                        <div className="transform-handle" style={{ left: size + transform.x - 6, top: size + transform.y + imgH / 2 - 6, cursor: 'ns-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'b')} />
                        <div className="transform-handle" style={{ left: size + transform.x - imgW / 2 - 6, top: size + transform.y - 6, cursor: 'ew-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'l')} />
                        <div className="transform-handle" style={{ left: size + transform.x + imgW / 2 - 6, top: size + transform.y - 6, cursor: 'ew-resize' }} 
                          onMouseDown={(e) => handleTransformStart(e, 'r')} />
                      </>
                    )}
                  </div>
                </div>
              </div>

              <div className="w-64 bg-white shadow-lg p-6 flex flex-col gap-4 overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">사이즈 선택</h2>
                {SIZES.map((s, i) => (
                  <button key={i} onClick={() => { setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, scaleX: 1, scaleY: 1 }); }}
                    className={`px-4 py-3 rounded-lg font-medium transition-colors text-left ${selectedSize.label === s.label ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`}>
                    {s.label}
                  </button>
                ))}

                <div className="mt-8 flex flex-col gap-3">
                  <button onClick={() => fileInputRef.current?.click()}
                    className="flex items-center justify-center gap-2 px-4 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                      <polyline points="17 8 12 3 7 8"></polyline>
                      <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    사진 업로드
                  </button>

                  {image && (
                    <div className="flex gap-2">
                      <button onClick={zoomOut} className="flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                          <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                      </button>
                      <button onClick={zoomIn} className="flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                          <line x1="12" y1="5" x2="12" y2="19"></line>
                          <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                      </button>
                    </div>
                  )}

                  <button onClick={downloadImage} disabled={!image}
                    className={`flex items-center justify-center gap-2 px-4 py-3 rounded-lg ${image ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                      <polyline points="7 10 12 15 17 10"></polyline>
                      <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    PNG 다운로드
                  </button>
                </div>

                {image && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg text-sm text-gray-700">
                    <p className="font-medium mb-1">사용 방법:</p>
                    <ul className="space-y-1 text-xs">
                      <li>• 드래그: 이미지 이동</li>
                      <li>• 모서리: 전체 크기 조절</li>
                      <li>• 상하좌우: 한쪽만 조절</li>
                      <li>• 휠/+- 버튼: 확대/축소</li>
                    </ul>
                  </div>
                )}
              </div>

              <input ref={fileInputRef} type="file" accept="image/*" onChange={handleFileSelect} className="hidden" />
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>