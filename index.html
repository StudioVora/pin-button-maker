<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스튜디오 보라 _ 핀버튼 도안 제작기</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        * { box-sizing: border-box; }
        .transform-handle {
            width: 14px; height: 14px; background: white; border: 2px solid #3b82f6;
            border-radius: 50%; position: absolute; z-index: 10; transform: translate(-50%, -50%);
        }
        .transform-handle:hover { background: #3b82f6; transform: translate(-50%, -50%) scale(1.2); }
        @media (max-width: 768px) { .desktop-only { display: none !important; } }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const SIZES = [
          { inner: 25, outer: 35, label: '25mm - 35mm', type: 'circle' },
          { inner: 32, outer: 44, label: '32mm - 44mm', type: 'circle' },
          { inner: 44, outer: 54, label: '44mm - 54mm', type: 'circle', default: true },
          { inner: 58, outer: 69.5, label: '58mm - 69.5mm', type: 'circle' },
          { inner: 75, outer: 85, label: '75mm - 85mm', type: 'circle' },
          { inner: 50, outer: 61, label: '50mm - 61mm (네모)', type: 'square' },
          { inner: 54.287, outer: 70, label: '54mm - 70mm (하트)', type: 'heart' }
        ];

        const App = () => {
          const [selectedSize, setSelectedSize] = useState(SIZES.find(s => s.default));
          const [image, setImage] = useState(null);
          const [transform, setTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isDragging, setIsDragging] = useState(false);
          const [isResizing, setIsResizing] = useState(false);
          const [resizeHandle, setResizeHandle] = useState(null);
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [startTransform, setStartTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isMobile, setIsMobile] = useState(false);
          const fileInputRef = useRef(null);
          const imageRef = useRef(null);
          const SCALE_FACTOR = 4;

          useEffect(() => {
            const check = () => setIsMobile(window.innerWidth <= 768);
            check();
            window.addEventListener('resize', check);
            return () => window.removeEventListener('resize', check);
          }, []);

          const loadImage = (file) => {
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  const size = selectedSize.outer * 3;
                  const scale = Math.min(size * 2 / img.width, size * 2 / img.height);
                  setImage(e.target.result);
                  setTransform({ x: 0, y: 0, width: img.width * scale, height: img.height * scale });
                };
                img.src = e.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleMouseDown = (e) => {
            if (!image || e.target.classList.contains('transform-handle')) return;
            setIsDragging(true);
            setStartPos({ x: e.clientX - transform.x, y: e.clientY - transform.y });
          };

          const handleMouseMove = (e) => {
            if (isDragging) {
              setTransform(prev => ({ ...prev, x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
            } else if (isResizing && resizeHandle) {
              const dx = e.clientX - startPos.x;
              const dy = e.clientY - startPos.y;
              let newWidth = startTransform.width, newHeight = startTransform.height;
              let newX = startTransform.x, newY = startTransform.y;

              switch (resizeHandle) {
                case 'tl': newWidth -= dx; newHeight -= dy; newX += dx; newY += dy; break;
                case 'tr': newWidth += dx; newHeight -= dy; newY += dy; break;
                case 'bl': newWidth -= dx; newHeight += dy; newX += dx; break;
                case 'br': newWidth += dx; newHeight += dy; break;
                case 't': newHeight -= dy; newY += dy; break;
                case 'b': newHeight += dy; break;
                case 'l': newWidth -= dx; newX += dx; break;
                case 'r': newWidth += dx; break;
              }
              if (newWidth > 20 && newHeight > 20) {
                setTransform({ x: newX, y: newY, width: newWidth, height: newHeight });
              }
            }
          };

          const handleMouseUp = () => { setIsDragging(false); setIsResizing(false); setResizeHandle(null); };

          const handleResizeStart = (e, handle) => {
            e.stopPropagation();
            setIsResizing(true);
            setResizeHandle(handle);
            setStartPos({ x: e.clientX, y: e.clientY });
            setStartTransform({ ...transform });
          };

          const handleTouchStart = (e) => {
            if (!image) return;
            if (e.touches.length === 1) {
              setIsDragging(true);
              setStartPos({ x: e.touches[0].clientX - transform.x, y: e.touches[0].clientY - transform.y });
            } else if (e.touches.length === 2) {
              const t1 = e.touches[0], t2 = e.touches[1];
              setStartPos({ dist: Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY), transform: { ...transform } });
            }
          };

          const handleTouchMove = (e) => {
            if (!image) return;
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
              setTransform(prev => ({ ...prev, x: e.touches[0].clientX - startPos.x, y: e.touches[0].clientY - startPos.y }));
            } else if (e.touches.length === 2) {
              const t1 = e.touches[0], t2 = e.touches[1];
              const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
              const scale = dist / startPos.dist;
              setTransform({ x: startPos.transform.x, y: startPos.transform.y, 
                width: startPos.transform.width * scale, height: startPos.transform.height * scale });
            }
          };

          const handleTouchEnd = () => setIsDragging(false);

          const zoom = (factor) => {
            setTransform(prev => ({ ...prev, width: prev.width * factor, height: prev.height * factor }));
          };

          const downloadImage = () => {
            if (!image || !imageRef.current) return;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const outerSize = selectedSize.outer * SCALE_FACTOR;
            const displaySize = selectedSize.outer * 3;
            const ratio = outerSize / displaySize;
            canvas.width = outerSize * 2;
            canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
            const cx = canvas.width / 2, cy = canvas.width / 2;

            ctx.save();
            ctx.translate(cx + transform.x * ratio, cy + transform.y * ratio);
            ctx.drawImage(imageRef.current, -transform.width * ratio / 2, -transform.height * ratio / 2, 
              transform.width * ratio, transform.height * ratio);
            ctx.restore();

            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const r = outerSize * 0.15;
              ctx.moveTo(cx - outerSize + r, cy - outerSize);
              ctx.lineTo(cx + outerSize - r, cy - outerSize);
              ctx.quadraticCurveTo(cx + outerSize, cy - outerSize, cx + outerSize, cy - outerSize + r);
              ctx.lineTo(cx + outerSize, cy + outerSize - r);
              ctx.quadraticCurveTo(cx + outerSize, cy + outerSize, cx + outerSize - r, cy + outerSize);
              ctx.lineTo(cx - outerSize + r, cy + outerSize);
              ctx.quadraticCurveTo(cx - outerSize, cy + outerSize, cx - outerSize, cy + outerSize - r);
              ctx.lineTo(cx - outerSize, cy - outerSize + r);
              ctx.quadraticCurveTo(cx - outerSize, cy - outerSize, cx - outerSize + r, cy - outerSize);
              ctx.closePath();
            } else {
              ctx.moveTo(cx, cy - outerSize * 0.25);
              ctx.bezierCurveTo(cx - outerSize * 0.55, cy - outerSize * 0.85, cx - outerSize * 1.15, cy + outerSize * 0.05, cx, cy + outerSize * 0.95);
              ctx.bezierCurveTo(cx + outerSize * 1.15, cy + outerSize * 0.05, cx + outerSize * 0.55, cy - outerSize * 0.85, cx, cy - outerSize * 0.25);
              ctx.closePath();
            }
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const r = outerSize * 0.15;
              ctx.moveTo(cx - outerSize + r, cy - outerSize);
              ctx.lineTo(cx + outerSize - r, cy - outerSize);
              ctx.quadraticCurveTo(cx + outerSize, cy - outerSize, cx + outerSize, cy - outerSize + r);
              ctx.lineTo(cx + outerSize, cy + outerSize - r);
              ctx.quadraticCurveTo(cx + outerSize, cy + outerSize, cx + outerSize - r, cy + outerSize);
              ctx.lineTo(cx - outerSize + r, cy + outerSize);
              ctx.quadraticCurveTo(cx - outerSize, cy + outerSize, cx - outerSize, cy + outerSize - r);
              ctx.lineTo(cx - outerSize, cy - outerSize + r);
              ctx.quadraticCurveTo(cx - outerSize, cy - outerSize, cx - outerSize + r, cy - outerSize);
              ctx.closePath();
            } else {
              ctx.moveTo(cx, cy - outerSize * 0.25);
              ctx.bezierCurveTo(cx - outerSize * 0.55, cy - outerSize * 0.85, cx - outerSize * 1.15, cy + outerSize * 0.05, cx, cy + outerSize * 0.95);
              ctx.bezierCurveTo(cx + outerSize * 1.15, cy + outerSize * 0.05, cx + outerSize * 0.55, cy - outerSize * 0.85, cx, cy - outerSize * 0.25);
              ctx.closePath();
            }
            ctx.stroke();

            ctx.beginPath();
            if (selectedSize.type === 'heart') {
              const nw = 6 * SCALE_FACTOR, nd = 2 * SCALE_FACTOR;
              ctx.moveTo(cx - nw / 2, 0);
              ctx.lineTo(cx - nw / 2, nd);
              ctx.quadraticCurveTo(cx, nd * 1.5, cx + nw / 2, nd);
              ctx.lineTo(cx + nw / 2, 0);
            } else {
              ctx.moveTo(cx, 0);
              ctx.lineTo(cx, 2 * SCALE_FACTOR);
            }
            ctx.stroke();

            canvas.toBlob((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `pin-button-${selectedSize.label}.png`;
              a.click();
              URL.revokeObjectURL(url);
            }, 'image/png');
          };

          useEffect(() => {
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            return () => {
              document.removeEventListener('mouseup', handleMouseUp);
              document.removeEventListener('mousemove', handleMouseMove);
            };
          }, [isDragging, isResizing, startPos, startTransform, resizeHandle]);

          const size = selectedSize.outer * 3;
          const innerSize = selectedSize.inner * 3;

          const Shape = () => {
            const common = { display: 'block', touchAction: 'none' };
            const clipId = 'clip';
            
            if (selectedSize.type === 'circle') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common}>
                  {image && <><defs><clipPath id={clipId}><circle cx={size} cy={size} r={size} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2} 
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" /></>}
                  <circle cx={size} cy={size} r={size} fill="none" stroke="#000" strokeWidth="2" />
                  <circle cx={size} cy={size} r={innerSize} fill="none" stroke="#f00" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}}>
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else if (selectedSize.type === 'square') {
              const r = size * 0.15, ir = innerSize * 0.82;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common}>
                  {image && <><defs><clipPath id={clipId}><rect x={0} y={0} width={size * 2} height={size * 2} rx={r} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" /></>}
                  <rect x={0} y={0} width={size * 2} height={size * 2} rx={r} fill="none" stroke="#000" strokeWidth="2" />
                  <rect x={size - innerSize} y={size - innerSize} width={innerSize * 2} height={innerSize * 2} rx={ir} fill="none" stroke="#f00" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}}>
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else {
              const hp = `M ${size},${size * 0.75} C ${size * 0.45},${size * 0.15} ${size * -0.15},${size * 1.05} ${size},${size * 1.95} C ${size * 2.15},${size * 1.05} ${size * 1.55},${size * 0.15} ${size},${size * 0.75} Z`;
              const ip = `M ${size},${size * 0.815} C ${size * 0.485},${size * 0.255} ${size * -0.06},${size * 1.085} ${size},${size * 1.835} C ${size * 2.06},${size * 1.085} ${size * 1.515},${size * 0.255} ${size},${size * 0.815} Z`;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common}>
                  {image && <><defs><clipPath id={clipId}><path d={hp} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} clipPath={`url(#${clipId})`} pointerEvents="none" /></>}
                  <path d={hp} fill="none" stroke="#000" strokeWidth="2" />
                  <path d={ip} fill="none" stroke="#f00" strokeWidth="2" />
                  <path d={`M ${size - 6},0 L ${size - 6},6 Q ${size},9 ${size + 6},6 L ${size + 6},0`} fill="none" stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}}>
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            }
          };

          return (
            <div className={`flex ${isMobile ? 'flex-col' : ''} h-screen bg-gray-100`}>
              <div className={`${isMobile ? 'flex-1 order-2' : 'flex-1'} flex items-center justify-center p-4 overflow-auto`}>
                <div className="relative bg-white rounded-lg shadow-lg p-6" 
                  onDrop={(e) => { e.preventDefault(); loadImage(e.dataTransfer.files[0]); }} 
                  onDragOver={(e) => e.preventDefault()} onMouseDown={handleMouseDown}
                  onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                  <div style={{ position: 'relative' }}>
                    <Shape />
                    {image && !isMobile && ['tl','tr','bl','br','t','b','l','r'].map(h => {
                      const cursors = {tl:'nwse-resize',tr:'nesw-resize',bl:'nesw-resize',br:'nwse-resize',t:'ns-resize',b:'ns-resize',l:'ew-resize',r:'ew-resize'};
                      const pos = {
                        tl: [transform.x - transform.width / 2, transform.y - transform.height / 2],
                        tr: [transform.x + transform.width / 2, transform.y - transform.height / 2],
                        bl: [transform.x - transform.width / 2, transform.y + transform.height / 2],
                        br: [transform.x + transform.width / 2, transform.y + transform.height / 2],
                        t: [transform.x, transform.y - transform.height / 2],
                        b: [transform.x, transform.y + transform.height / 2],
                        l: [transform.x - transform.width / 2, transform.y],
                        r: [transform.x + transform.width / 2, transform.y]
                      };
                      return <div key={h} className="transform-handle" 
                        style={{ left: size + pos[h][0], top: size + pos[h][1], cursor: cursors[h] }} 
                        onMouseDown={(e) => handleResizeStart(e, h)} />;
                    })}
                  </div>
                </div>
              </div>

              <div className={`${isMobile ? 'order-1 w-full' : 'w-64'} bg-white shadow-lg p-4 flex ${isMobile ? 'flex-row flex-wrap' : 'flex-col'} gap-3 overflow-auto`}>
                <h2 className={`${isMobile ? 'w-full' : ''} text-lg font-bold mb-2`}>스튜디오 보라</h2>
                
                {!isMobile ? SIZES.map((s, i) => (
                  <button key={i} onClick={() => { setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 }); }}
                    className={`px-4 py-2 rounded-lg text-sm font-medium text-left ${selectedSize.label === s.label ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`}>
                    {s.label}
                  </button>
                )) : (
                  <select value={selectedSize.label} onChange={(e) => {
                    const s = SIZES.find(sz => sz.label === e.target.value);
                    setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 });
                  }} className="flex-1 px-3 py-2 rounded-lg bg-blue-500 text-white text-sm font-medium">
                    {SIZES.map((s, i) => <option key={i} value={s.label}>{s.label}</option>)}
                  </select>
                )}

                <button onClick={() => fileInputRef.current?.click()}
                  className={`${isMobile ? 'flex-1' : 'mt-4'} flex items-center justify-center gap-2 px-4 py-2 bg-green-500 text-white text-sm rounded-lg hover:bg-green-600`}>
                  ⬆ {isMobile ? '업로드' : '사진 업로드'}
                </button>

                {image && (
                  <div className={`flex gap-2 ${isMobile ? 'flex-1' : ''}`}>
                    <button onClick={() => zoom(0.9)} className="flex-1 px-3 py-2 bg-gray-500 text-white text-lg rounded-lg hover:bg-gray-600">−</button>
                    <button onClick={() => zoom(1.1)} className="flex-1 px-3 py-2 bg-gray-500 text-white text-lg rounded-lg hover:bg-gray-600">+</button>
                  </div>
                )}

                <button onClick={downloadImage} disabled={!image}
                  className={`${isMobile ? 'flex-1' : ''} flex items-center justify-center gap-2 px-4 py-2 text-sm rounded-lg ${image ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500'}`}>
                  ⬇ {isMobile ? '다운' : 'PNG 다운로드'}
                </button>

                {image && !isMobile && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg text-xs text-gray-700">
                    <p className="font-bold mb-1">사용법:</p>
                    <p>• 드래그: 이동</p>
                    <p>• 핸들: 크기조절</p>
                    <p>• +/- : 확대축소</p>
                  </div>
                )}
              </div>

              <input ref={fileInputRef} type="file" accept="image/*" onChange={(e) => loadImage(e.target.files?.[0])} className="hidden" />
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>