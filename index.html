<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>핀버튼 도안 제작</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        .transform-handle {
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            z-index: 10;
        }
        .transform-handle:hover {
            background: #3b82f6;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const SIZES = [
          { inner: 25, outer: 35, label: '25mm - 35mm', type: 'circle' },
          { inner: 32, outer: 44, label: '32mm - 44mm', type: 'circle' },
          { inner: 44, outer: 54, label: '44mm - 54mm', type: 'circle', default: true },
          { inner: 58, outer: 69.5, label: '58mm - 69.5mm', type: 'circle' },
          { inner: 75, outer: 85, label: '75mm - 85mm', type: 'circle' },
          { inner: 50, outer: 61, label: '50mm - 61mm (네모)', type: 'square' },
          { inner: 54.287, outer: 70, label: '54mm - 70mm (하트)', type: 'heart' }
        ];

        const UploadIcon = () => (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
        );

        const DownloadIcon = () => (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        );

        const PlusIcon = () => (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        );

        const MinusIcon = () => (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        );

        const PinButtonEditor = () => {
          const [selectedSize, setSelectedSize] = useState(SIZES.find(s => s.default));
          const [image, setImage] = useState(null);
          const [imageTransform, setImageTransform] = useState({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
          const [isDragging, setIsDragging] = useState(false);
          const [isTransforming, setIsTransforming] = useState(false);
          const [transformHandle, setTransformHandle] = useState(null);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [transformStart, setTransformStart] = useState({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
          const fileInputRef = useRef(null);
          const imageRef = useRef(null);
          const containerRef = useRef(null);
          const canvasContainerRef = useRef(null);

          const SCALE_FACTOR = 4;

          const handleFileSelect = (e) => {
            const file = e.target.files?.[0];
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  setImage(event.target.result);
                  setImageTransform({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
                };
                img.src = event.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleDrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  setImage(event.target.result);
                  setImageTransform({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
                };
                img.src = event.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
          };

          const handleMouseDown = (e) => {
            if (!image || e.target.classList.contains('transform-handle')) return;
            setIsDragging(true);
            setDragStart({ x: e.clientX - imageTransform.x, y: e.clientY - imageTransform.y });
          };

          const handleMouseMove = (e) => {
            if (isDragging && image) {
              setImageTransform(prev => ({
                ...prev,
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y
              }));
            }
          };

          const handleMouseUp = () => {
            setIsDragging(false);
            setIsTransforming(false);
          };

          const handleTransformStart = (e, corner) => {
            e.stopPropagation();
            setIsTransforming(true);
            setTransformHandle(corner);
            const rect = canvasContainerRef.current.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            setTransformStart({ 
              x: e.clientX,
              y: e.clientY,
              scaleX: imageTransform.scaleX,
              scaleY: imageTransform.scaleY,
              centerX,
              centerY,
              imgX: imageTransform.x,
              imgY: imageTransform.y
            });
          };

          const handleTransformMove = (e) => {
            if (!isTransforming || !transformHandle) return;
            
            const dx = e.clientX - transformStart.x;
            const dy = e.clientY - transformStart.y;
            
            let newScaleX = transformStart.scaleX;
            let newScaleY = transformStart.scaleY;
            
            const scaleFactor = 0.01;
            
            if (transformHandle === 'tl' || transformHandle === 'tr' || transformHandle === 'bl' || transformHandle === 'br') {
              // 모서리: 양쪽 다 조절
              const avgDelta = (dx + dy) / 2;
              const scaleChange = 1 + avgDelta * scaleFactor;
              newScaleX = Math.max(0.1, Math.min(5, transformStart.scaleX * scaleChange));
              newScaleY = Math.max(0.1, Math.min(5, transformStart.scaleY * scaleChange));
            } else if (transformHandle === 't' || transformHandle === 'b') {
              // 위/아래: 세로만 조절
              const scaleChange = 1 + dy * scaleFactor * (transformHandle === 'b' ? 1 : -1);
              newScaleY = Math.max(0.1, Math.min(5, transformStart.scaleY * scaleChange));
              newScaleX = transformStart.scaleX;
            } else if (transformHandle === 'l' || transformHandle === 'r') {
              // 좌/우: 가로만 조절
              const scaleChange = 1 + dx * scaleFactor * (transformHandle === 'r' ? 1 : -1);
              newScaleX = Math.max(0.1, Math.min(5, transformStart.scaleX * scaleChange));
              newScaleY = transformStart.scaleY;
            }
            
            setImageTransform(prev => ({
              ...prev,
              scaleX: newScaleX,
              scaleY: newScaleY
            }));
          };

          useEffect(() => {
            if (isTransforming) {
              document.addEventListener('mousemove', handleTransformMove);
            }
            return () => {
              document.removeEventListener('mousemove', handleTransformMove);
            };
          }, [isTransforming, transformStart, transformHandle]);

          const handleTouchStart = (e) => {
            if (!image) return;
            if (e.touches.length === 1) {
              setIsDragging(true);
              setDragStart({ 
                x: e.touches[0].clientX - imageTransform.x, 
                y: e.touches[0].clientY - imageTransform.y 
              });
            }
          };

          const handleTouchMove = (e) => {
            if (!image) return;
            if (e.touches.length === 1 && isDragging) {
              e.preventDefault();
              setImageTransform(prev => ({
                ...prev,
                x: e.touches[0].clientX - dragStart.x,
                y: e.touches[0].clientY - dragStart.y
              }));
            } else if (e.touches.length === 2) {
              e.preventDefault();
              const touch1 = e.touches[0];
              const touch2 = e.touches[1];
              const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
              
              if (!containerRef.current.lastDist) {
                containerRef.current.lastDist = dist;
                return;
              }
              
              const delta = dist - containerRef.current.lastDist;
              containerRef.current.lastDist = dist;
              
              setImageTransform(prev => ({
                ...prev,
                scaleX: Math.max(0.1, Math.min(5, prev.scaleX + delta * 0.01)),
                scaleY: Math.max(0.1, Math.min(5, prev.scaleY + delta * 0.01))
              }));
            }
          };

          const handleTouchEnd = () => {
            setIsDragging(false);
            if (containerRef.current) {
              containerRef.current.lastDist = null;
            }
          };

          const handleWheel = (e) => {
            if (!image) return;
            e.preventDefault();
            const delta = -e.deltaY * 0.001;
            setImageTransform(prev => ({
              ...prev,
              scaleX: Math.max(0.1, Math.min(5, prev.scaleX + delta)),
              scaleY: Math.max(0.1, Math.min(5, prev.scaleY + delta))
            }));
          };

          const zoomIn = () => {
            setImageTransform(prev => ({
              ...prev,
              scaleX: Math.min(5, prev.scaleX + 0.1),
              scaleY: Math.min(5, prev.scaleY + 0.1)
            }));
          };

          const zoomOut = () => {
            setImageTransform(prev => ({
              ...prev,
              scaleX: Math.max(0.1, prev.scaleX - 0.1),
              scaleY: Math.max(0.1, prev.scaleY - 0.1)
            }));
          };

          const handleDownload = () => {
            if (!image || !imageRef.current) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const outerSize = selectedSize.outer * SCALE_FACTOR;
            const displaySize = selectedSize.outer * 3;
            const scaleRatio = outerSize / displaySize;

            if (selectedSize.type === 'circle') {
              canvas.width = outerSize * 2;
              canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
              const centerX = canvas.width / 2;
              const centerY = canvas.width / 2;

              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.translate(imageTransform.x * scaleRatio, imageTransform.y * scaleRatio);
              ctx.scale(imageTransform.scaleX, imageTransform.scaleY);
              const imgWidth = imageRef.current.width * scaleRatio;
              const imgHeight = imageRef.current.height * scaleRatio;
              ctx.drawImage(imageRef.current, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
              ctx.restore();

              ctx.globalCompositeOperation = 'destination-in';
              ctx.beginPath();
              ctx.arc(centerX, centerY, outerSize, 0, Math.PI * 2);
              ctx.fill();

              ctx.globalCompositeOperation = 'source-over';
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(centerX, centerY, outerSize, 0, Math.PI * 2);
              ctx.stroke();

              ctx.beginPath();
              ctx.moveTo(centerX, 0);
              ctx.lineTo(centerX, 2 * SCALE_FACTOR);
              ctx.stroke();
            } else if (selectedSize.type === 'square') {
              canvas.width = outerSize * 2;
              canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
              const centerX = canvas.width / 2;
              const centerY = canvas.width / 2;
              const radius = outerSize * 0.15;

              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.translate(imageTransform.x * scaleRatio, imageTransform.y * scaleRatio);
              ctx.scale(imageTransform.scaleX, imageTransform.scaleY);
              const imgWidth = imageRef.current.width * scaleRatio;
              const imgHeight = imageRef.current.height * scaleRatio;
              ctx.drawImage(imageRef.current, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
              ctx.restore();

              ctx.globalCompositeOperation = 'destination-in';
              ctx.beginPath();
              ctx.moveTo(centerX - outerSize + radius, centerY - outerSize);
              ctx.lineTo(centerX + outerSize - radius, centerY - outerSize);
              ctx.quadraticCurveTo(centerX + outerSize, centerY - outerSize, centerX + outerSize, centerY - outerSize + radius);
              ctx.lineTo(centerX + outerSize, centerY + outerSize - radius);
              ctx.quadraticCurveTo(centerX + outerSize, centerY + outerSize, centerX + outerSize - radius, centerY + outerSize);
              ctx.lineTo(centerX - outerSize + radius, centerY + outerSize);
              ctx.quadraticCurveTo(centerX - outerSize, centerY + outerSize, centerX - outerSize, centerY + outerSize - radius);
              ctx.lineTo(centerX - outerSize, centerY - outerSize + radius);
              ctx.quadraticCurveTo(centerX - outerSize, centerY - outerSize, centerX - outerSize + radius, centerY - outerSize);
              ctx.closePath();
              ctx.fill();

              ctx.globalCompositeOperation = 'source-over';
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(centerX - outerSize + radius, centerY - outerSize);
              ctx.lineTo(centerX + outerSize - radius, centerY - outerSize);
              ctx.quadraticCurveTo(centerX + outerSize, centerY - outerSize, centerX + outerSize, centerY - outerSize + radius);
              ctx.lineTo(centerX + outerSize, centerY + outerSize - radius);
              ctx.quadraticCurveTo(centerX + outerSize, centerY + outerSize, centerX + outerSize - radius, centerY + outerSize);
              ctx.lineTo(centerX - outerSize + radius, centerY + outerSize);
              ctx.quadraticCurveTo(centerX - outerSize, centerY + outerSize, centerX - outerSize, centerY + outerSize - radius);
              ctx.lineTo(centerX - outerSize, centerY - outerSize + radius);
              ctx.quadraticCurveTo(centerX - outerSize, centerY - outerSize, centerX - outerSize + radius, centerY - outerSize);
              ctx.closePath();
              ctx.stroke();

              ctx.beginPath();
              ctx.moveTo(centerX, 0);
              ctx.lineTo(centerX, 2 * SCALE_FACTOR);
              ctx.stroke();
            } else if (selectedSize.type === 'heart') {
              canvas.width = outerSize * 2;
              canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
              const centerX = canvas.width / 2;
              const centerY = canvas.width / 2;

              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.translate(imageTransform.x * scaleRatio, imageTransform.y * scaleRatio);
              ctx.scale(imageTransform.scale, imageTransform.scale);
              const imgWidth = imageRef.current.width * scaleRatio;
              const imgHeight = imageRef.current.height * scaleRatio;
              ctx.drawImage(imageRef.current, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
              ctx.restore();

              ctx.globalCompositeOperation = 'destination-in';
              ctx.beginPath();
              ctx.moveTo(centerX, centerY - outerSize * 0.3);
              ctx.bezierCurveTo(
                centerX - outerSize * 0.6, centerY - outerSize * 0.9,
                centerX - outerSize * 1.2, centerY - outerSize * 0.1,
                centerX, centerY + outerSize * 0.9
              );
              ctx.bezierCurveTo(
                centerX + outerSize * 1.2, centerY - outerSize * 0.1,
                centerX + outerSize * 0.6, centerY - outerSize * 0.9,
                centerX, centerY - outerSize * 0.3
              );
              ctx.closePath();
              ctx.fill();

              ctx.globalCompositeOperation = 'source-over';
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(centerX, centerY - outerSize * 0.3);
              ctx.bezierCurveTo(
                centerX - outerSize * 0.6, centerY - outerSize * 0.9,
                centerX - outerSize * 1.2, centerY - outerSize * 0.1,
                centerX, centerY + outerSize * 0.9
              );
              ctx.bezierCurveTo(
                centerX + outerSize * 1.2, centerY - outerSize * 0.1,
                centerX + outerSize * 0.6, centerY - outerSize * 0.9,
                centerX, centerY - outerSize * 0.3
              );
              ctx.closePath();
              ctx.stroke();

              const notchDepth = 2 * SCALE_FACTOR;
              const notchWidth = 6 * SCALE_FACTOR;
              ctx.beginPath();
              ctx.moveTo(centerX - notchWidth/2, 0);
              ctx.lineTo(centerX - notchWidth/2, notchDepth);
              ctx.quadraticCurveTo(centerX, notchDepth * 1.5, centerX + notchWidth/2, notchDepth);
              ctx.lineTo(centerX + notchWidth/2, 0);
              ctx.stroke();
            }

            canvas.toBlob((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `pin-button-${selectedSize.label}.png`;
              a.click();
              URL.revokeObjectURL(url);
            }, 'image/png');
          };

          useEffect(() => {
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            return () => {
              document.removeEventListener('mouseup', handleMouseUp);
              document.removeEventListener('mousemove', handleMouseMove);
            };
          }, [isDragging, dragStart, image]);

          const renderShape = () => {
            const size = selectedSize.outer * 3;
            const innerSize = selectedSize.inner * 3;

            if (selectedSize.type === 'circle') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="outerClip">
                          <circle cx={size} cy={size} r={size} />
                        </clipPath>
                      </defs>
                      <image
                        href={image}
                        x={size + imageTransform.x - (imageRef.current?.width || 0) * imageTransform.scaleX / 2}
                        y={size + imageTransform.y - (imageRef.current?.height || 0) * imageTransform.scaleY / 2}
                        width={(imageRef.current?.width || 0) * imageTransform.scaleX}
                        height={(imageRef.current?.height || 0) * imageTransform.scaleY}
                        clipPath="url(#outerClip)"
                        style={{ pointerEvents: 'none' }}
                      />
                    </g>
                  )}
                  <circle cx={size} cy={size} r={size} fill="none" stroke="#000000" strokeWidth="2" />
                  <circle cx={size} cy={size} r={innerSize} fill="none" stroke="#FF0000" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000000" strokeWidth="1" />
                  {!image && (
                    <g>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" style={{ cursor: 'pointer' }} onClick={() => fileInputRef.current?.click()} />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" style={{ cursor: 'pointer', pointerEvents: 'none' }}>+</text>
                    </g>
                  )}
                </svg>
              );
            } else if (selectedSize.type === 'square') {
              const radius = size * 0.15;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="squareClip">
                          <rect x={0} y={0} width={size * 2} height={size * 2} rx={radius} ry={radius} />
                        </clipPath>
                      </defs>
                      <image
                        href={image}
                        x={size + imageTransform.x - (imageRef.current?.width || 0) * imageTransform.scaleX / 2}
                        y={size + imageTransform.y - (imageRef.current?.height || 0) * imageTransform.scaleY / 2}
                        width={(imageRef.current?.width || 0) * imageTransform.scaleX}
                        height={(imageRef.current?.height || 0) * imageTransform.scaleY}
                        clipPath="url(#squareClip)"
                        style={{ pointerEvents: 'none' }}
                      />
                    </g>
                  )}
                  <rect x={0} y={0} width={size * 2} height={size * 2} rx={radius} ry={radius} fill="none" stroke="#000000" strokeWidth="2" />
                  <rect x={size - innerSize} y={size - innerSize} width={innerSize * 2} height={innerSize * 2} rx={radius * 0.82} ry={radius * 0.82} fill="none" stroke="#FF0000" strokeWidth="2" />
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000000" strokeWidth="1" />
                  {!image && (
                    <g>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" style={{ cursor: 'pointer' }} onClick={() => fileInputRef.current?.click()} />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" style={{ cursor: 'pointer', pointerEvents: 'none' }}>+</text>
                    </g>
                  )}
                </svg>
              );
            } else if (selectedSize.type === 'heart') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={{ display: 'block', touchAction: 'none' }}>
                  {image && (
                    <g>
                      <defs>
                        <clipPath id="heartClip">
                          <path d={`M ${size},${size * 0.75}
                                   C ${size * 0.45},${size * 0.15} ${size * -0.15},${size * 1.05} ${size},${size * 1.95}
                                   C ${size * 2.15},${size * 1.05} ${size * 1.55},${size * 0.15} ${size},${size * 0.75} Z`} />
                        </clipPath>
                      </defs>
                      <image
                        href={image}
                        x={size + imageTransform.x - (imageRef.current?.width || 0) * imageTransform.scaleX / 2}
                        y={size + imageTransform.y - (imageRef.current?.height || 0) * imageTransform.scaleY / 2}
                        width={(imageRef.current?.width || 0) * imageTransform.scaleX}
                        height={(imageRef.current?.height || 0) * imageTransform.scaleY}
                        clipPath="url(#heartClip)"
                        style={{ pointerEvents: 'none' }}
                      />
                    </g>
                  )}
                  <path d={`M ${size},${size * 0.75}
                           C ${size * 0.45},${size * 0.15} ${size * -0.15},${size * 1.05} ${size},${size * 1.95}
                           C ${size * 2.15},${size * 1.05} ${size * 1.55},${size * 0.15} ${size},${size * 0.75} Z`}
                        fill="none" stroke="#000000" strokeWidth="2" />
                  <path d={`M ${size},${size * 0.815}
                           C ${size * 0.485},${size * 0.255} ${size * -0.06},${size * 1.085} ${size},${size * 1.835}
                           C ${size * 2.06},${size * 1.085} ${size * 1.515},${size * 0.255} ${size},${size * 0.815} Z`}
                        fill="none" stroke="#FF0000" strokeWidth="2" />
                  <path d={`M ${size - 6},0 L ${size - 6},6 Q ${size},9 ${size + 6},6 L ${size + 6},0`} 
                        fill="none" stroke="#000000" strokeWidth="1" />
                  {!image && (
                    <g>
                      <circle cx={size} cy={size} r={30} fill="#f3f4f6" style={{ cursor: 'pointer' }} onClick={() => fileInputRef.current?.click()} />
                      <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" style={{ cursor: 'pointer', pointerEvents: 'none' }}>+</text>
                    </g>
                  )}
                </svg>
              );
            }
          };

          const size = selectedSize.outer * 3;
          const imgWidth = (imageRef.current?.width || 0) * imageTransform.scale;
          const imgHeight = (imageRef.current?.height || 0) * imageTransform.scale;

          return (
            <div className="flex h-screen bg-gray-100">
              <div className="flex-1 flex items-center justify-center p-8">
                <div
                  ref={containerRef}
                  className="relative bg-white rounded-lg shadow-lg p-12"
                  style={{ width: 'fit-content' }}
                  onDrop={handleDrop}
                  onDragOver={handleDragOver}
                  onMouseDown={handleMouseDown}
                  onTouchStart={handleTouchStart}
                  onTouchMove={handleTouchMove}
                  onTouchEnd={handleTouchEnd}
                  onWheel={handleWheel}
                >
                  <div ref={canvasContainerRef} style={{ position: 'relative' }}>
                    {renderShape()}
                    
                    {image && (
                      <>
                        <div
                          className="transform-handle"
                          style={{
                            left: size + imageTransform.x - imgWidth / 2 - 6,
                            top: size + imageTransform.y - imgHeight / 2 - 6,
                          }}
                          onMouseDown={(e) => handleTransformStart(e, 'bl')}
                        />
                        <div
                          className="transform-handle"
                          style={{
                            left: size + imageTransform.x + imgWidth / 2 - 6,
                            top: size + imageTransform.y + imgHeight / 2 - 6,
                          }}
                          onMouseDown={(e) => handleTransformStart(e, 'br')}
                        />
                      </>
                    )}
                  </div>
                </div>
              </div>

              <div className="w-64 bg-white shadow-lg p-6 flex flex-col gap-4 overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">사이즈 선택</h2>
                
                {SIZES.map((size, idx) => (
                  <button
                    key={idx}
                    onClick={() => {
                      setSelectedSize(size);
                      setImage(null);
                      setImageTransform({ x: 0, y: 0, scaleX: 1, scaleY: 1 });
                    }}
                    className={`px-4 py-3 rounded-lg font-medium transition-colors text-left ${
                      selectedSize.label === size.label
                        ? 'bg-blue-500 text-white'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    {size.label}
                  </button>
                ))}

                <div className="mt-8 flex flex-col gap-3">
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="flex items-center justify-center gap-2 px-4 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                  >
                    <UploadIcon />
                    사진 업로드
                  </button>

                  {image && (
                    <div className="flex gap-2">
                      <button
                        onClick={zoomOut}
                        className="flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
                      >
                        <MinusIcon />
                      </button>
                      <button
                        onClick={zoomIn}
                        className="flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
                      >
                        <PlusIcon />
                      </button>
                    </div>
                  )}

                  <button
                    onClick={handleDownload}
                    disabled={!image}
                    className={`flex items-center justify-center gap-2 px-4 py-3 rounded-lg transition-colors ${
                      image
                        ? 'bg-blue-500 text-white hover:bg-blue-600'
                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    }`}
                  >
                    <DownloadIcon />
                    PNG 다운로드
                  </button>
                </div>

                {image && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg text-sm text-gray-700">
                    <p className="font-medium mb-1">사용 방법:</p>
                    <ul className="space-y-1 text-xs">
                      <li>• 드래그: 이미지 이동</li>
                      <li>• 모서리 핸들: 크기 조절</li>
                      <li>• 휠/핀치/+- 버튼: 확대/축소</li>
                    </ul>
                  </div>
                )}
              </div>

              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                onChange={handleFileSelect}
                className="hidden"
              />
            </div>
          );
        };

        ReactDOM.render(<PinButtonEditor />, document.getElementById('root'));
    </script>
</body>
</html>e, 'tl')}
                        />
                        <div
                          className="transform-handle"
                          style={{
                            left: size + imageTransform.x + imgWidth / 2 - 6,
                            top: size + imageTransform.y - imgHeight / 2 - 6,
                          }}
                          onMouseDown={(e) => handleTransformStart(e, 'tr')}
                        />
                        <div
                          className="transform-handle"
                          style={{
                            left: size + imageTransform.x - imgWidth / 2 - 6,
                            top: size + imageTransform.y + imgHeight / 2 - 6,
                          }}
                          onMouseDown={(e) => handleTransformStart(