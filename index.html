<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïä§ÌäúÎîîÏò§ Î≥¥Îùº _ ÌïÄÎ≤ÑÌäº ÎèÑÏïà Ï†úÏûëÍ∏∞</title>
    <meta name="google-adsense-account" content="ca-pub-9005571517151133">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; padding: 0; overflow: hidden; touch-action: none; }
      * { box-sizing: border-box; }
       .transform-handle {
            width: 10px; 
            height: 10px; 
            background: white; 
            border: 1px solid #000;
            box-shadow: 0 0 0 1px white, 0 0 3px rgba(0,0,0,0.3);
            position: absolute; 
            z-index: 10; 
            transform: translate(-50%, -50%);
            cursor: inherit;
        }
        .transform-handle:hover { 
            background: #3b82f6; 
            border-color: #3b82f6;
            transform: translate(-50%, -50%) scale(1.3); 
        }
        .transform-handle.corner {
            border-radius: 0;
        }
        .transform-handle.edge {
            border-radius: 0;
            width: 10px;
            height: 10px;
        }
      @media (max-width: 768px) { .desktop-only { display: none !important; } }

      .touch-container { padding: 500px !important; }
      @media (max-width: 768px) { 
          .touch-container { padding: 100px !important; } 
      }
      
      @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.95); }
          to { opacity: 1; transform: scale(1); }
      }
      
      @keyframes slideIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
      }
      
      .fade-in { animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
      .slide-in { animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
      
      .btn-hover {
          transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .btn-hover:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .btn-hover:active {
          transform: translateY(0);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
</style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const SIZES = [
          { inner: 25, outer: 35, label: '25mm - 35mm', type: 'circle' },
          { inner: 32, outer: 44, label: '32mm - 44mm', type: 'circle' },
          { inner: 44, outer: 54, label: '44mm - 54mm', type: 'circle', default: true },
          { inner: 58, outer: 69.5, label: '58mm - 69.5mm', type: 'circle' },
          { inner: 75, outer: 85, label: '75mm - 85mm', type: 'circle' },
          { inner: 50, outer: 61, label: '50mm - 61mm (ÎÑ§Î™®)', type: 'square' },
          { inner: 54.287, outer: 70, label: '54mm - 70mm (ÌïòÌä∏)', type: 'heart' }
        ];

        const App = () => {
          const [selectedSize, setSelectedSize] = useState(SIZES.find(s => s.default));
          const [image, setImage] = useState(null);
          const [transform, setTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isDragging, setIsDragging] = useState(false);
          const [isResizing, setIsResizing] = useState(false);
          const [resizeHandle, setResizeHandle] = useState(null);
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [startTransform, setStartTransform] = useState({ x: 0, y: 0, width: 0, height: 0 });
          const [isMobile, setIsMobile] = useState(false);
          const [isInitialLoad, setIsInitialLoad] = useState(true);
          const fileInputRef = useRef(null);
          const imageRef = useRef(null);
          const SCALE_FACTOR = 4;

          useEffect(() => {
            const check = () => setIsMobile(window.innerWidth <= 768);
            check();
            window.addEventListener('resize', check);
            return () => window.removeEventListener('resize', check);
          }, []);

          const loadImage = (file) => {
            if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                  imageRef.current = img;
                  const size = selectedSize.outer * 3;
                  const scale = Math.min(size * 2 / img.width, size * 2 / img.height);
                  setImage(e.target.result);
                  setTransform({ x: 0, y: 0, width: img.width * scale, height: img.height * scale });
                };
                img.src = e.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const handleMouseDown = (e) => {
            if (!image || e.target.classList.contains('transform-handle')) return;
            setIsDragging(true);
            setStartPos({ x: e.clientX - transform.x, y: e.clientY - transform.y });
          };

          const handleMouseMove = (e) => {
            if (isDragging) {
              setTransform(prev => ({ ...prev, x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
            } else if (isResizing && resizeHandle) {
              const dx = e.clientX - startPos.x;
              const dy = e.clientY - startPos.y;
              let newWidth = startTransform.width;
              let newHeight = startTransform.height;
              let newX = startTransform.x;
              let newY = startTransform.y;

              if (['tl', 'tr', 'bl', 'br'].includes(resizeHandle)) {
                // ÎåÄÍ∞ÅÏÑ†: ÎπÑÏú® Ïú†ÏßÄ + Î∞òÎåÄÌé∏ Í≥†Ï†ï
                let dist = 0;
                if (resizeHandle === 'br') {
                  dist = (dx + dy) / 2;
                } else if (resizeHandle === 'tl') {
                  dist = -(dx + dy) / 2;
                } else if (resizeHandle === 'tr') {
                  dist = (dx - dy) / 2;
                } else if (resizeHandle === 'bl') {
                  dist = (-dx + dy) / 2;
                }
                const scale = 1 + dist / Math.max(startTransform.width, startTransform.height);
                newWidth = startTransform.width * scale;
                newHeight = startTransform.height * scale;
                
                // Î∞òÎåÄÌé∏ Í≥†Ï†ï (ÏÑ†ÌÉùÌïú Ìï∏Îì§ Ï™ΩÏúºÎ°úÎßå Ïù¥Îèô)
                if (resizeHandle === 'br') {
                  newX = startTransform.x + (newWidth - startTransform.width) / 2;
                  newY = startTransform.y + (newHeight - startTransform.height) / 2;
                } else if (resizeHandle === 'tl') {
                  newX = startTransform.x - (newWidth - startTransform.width) / 2;
                  newY = startTransform.y - (newHeight - startTransform.height) / 2;
                } else if (resizeHandle === 'tr') {
                  newX = startTransform.x + (newWidth - startTransform.width) / 2;
                  newY = startTransform.y - (newHeight - startTransform.height) / 2;
                } else if (resizeHandle === 'bl') {
                  newX = startTransform.x - (newWidth - startTransform.width) / 2;
                  newY = startTransform.y + (newHeight - startTransform.height) / 2;
                }
              } else if (resizeHandle === 't' || resizeHandle === 'b') {
                // ÏÉÅÌïò: ÏÑ∏Î°úÎßå Ï°∞Ï†à (ÎÇ©ÏûëÌïòÍ≤å)
                const delta = resizeHandle === 'b' ? dy : -dy;
                newHeight = startTransform.height + delta;
                newWidth = startTransform.width;
                // Î∞òÎåÄÌé∏ Í≥†Ï†ï
                if (resizeHandle === 'b') {
                  newY = startTransform.y + delta / 2;
                } else {
                  newY = startTransform.y - delta / 2;
                }
              } else if (resizeHandle === 'l' || resizeHandle === 'r') {
                // Ï¢åÏö∞: Í∞ÄÎ°úÎßå Ï°∞Ï†à (ÎÇ©ÏûëÌïòÍ≤å)
                const delta = resizeHandle === 'r' ? dx : -dx;
                newWidth = startTransform.width + delta;
                newHeight = startTransform.height;
                // Î∞òÎåÄÌé∏ Í≥†Ï†ï
                if (resizeHandle === 'r') {
                  newX = startTransform.x + delta / 2;
                } else {
                  newX = startTransform.x - delta / 2;
                }
              }

              if (newWidth > 20 && newHeight > 20) {
                setTransform({ x: newX, y: newY, width: newWidth, height: newHeight });
              }
            }
          };

          const handleMouseUp = () => { setIsDragging(false); setIsResizing(false); setResizeHandle(null); };

          const handleResizeStart = (e, handle) => {
            e.stopPropagation();
            setIsResizing(true);
            setResizeHandle(handle);
            setStartPos({ x: e.clientX, y: e.clientY });
            setStartTransform({ ...transform });
          };

           const handleTouchResizeStart = (e, handle) => {
            e.stopPropagation();
            if (e.touches.length === 1) {
              const touch = e.touches[0];
              setIsResizing(true);
              setResizeHandle(handle);
              setStartPos({ x: touch.clientX, y: touch.clientY });
              setStartTransform({ ...transform });
            }
          };

          const zoom = (factor) => {
            setTransform(prev => ({ ...prev, width: prev.width * factor, height: prev.height * factor }));
          };

          const moveImage = (dx, dy) => {
            setTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
          };

          const getZoomPercentage = () => {
            if (!imageRef.current || !image) return 100;
            const size = selectedSize.outer * 3;
            const initialScale = Math.min(size * 2 / imageRef.current.width, size * 2 / imageRef.current.height);
            const initialWidth = imageRef.current.width * initialScale;
            return Math.round((transform.width / initialWidth) * 100);
          };

          const resetImage = () => {
            if (!imageRef.current) return;
            const size = selectedSize.outer * 3;
            const scale = Math.min(size * 2 / imageRef.current.width, size * 2 / imageRef.current.height);
            setTransform({ 
              x: 0, 
              y: 0, 
              width: imageRef.current.width * scale, 
              height: imageRef.current.height * scale 
            });
          };

          const downloadImage = () => {
            if (!image || !imageRef.current) return;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const outerSize = selectedSize.outer * SCALE_FACTOR;
            const displaySize = selectedSize.outer * 3;
            const ratio = outerSize / displaySize;
            canvas.width = outerSize * 2;
            canvas.height = outerSize * 2 + 2 * SCALE_FACTOR;
            const cx = canvas.width / 2, cy = canvas.width / 2;

            ctx.save();
            ctx.translate(cx + transform.x * ratio, cy + transform.y * ratio);
            ctx.drawImage(imageRef.current, -transform.width * ratio / 2, -transform.height * ratio / 2, 
              transform.width * ratio, transform.height * ratio);
            ctx.restore();

            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              // ÎÑ§Î™® Ïã§Ï†ú SVG path Ï†ÅÏö© (Îã§Ïö¥Î°úÎìú, viewBox 200 Í∏∞Ï§Ä)
              const s = (outerSize * 2) / 200;
              const ox = cx - 100 * s;
              const oy = cy - 100 * s;
              
              const x1 = 13.54 * s + ox;
              const y1 = 13.22 * s + oy;
              const w1 = 172.91 * s;
              const h1 = 172.91 * s;
              const rx1 = 28.35 * s;
              
              ctx.moveTo(x1 + rx1, y1);
              ctx.lineTo(x1 + w1 - rx1, y1);
              ctx.quadraticCurveTo(x1 + w1, y1, x1 + w1, y1 + rx1);
              ctx.lineTo(x1 + w1, y1 + h1 - rx1);
              ctx.quadraticCurveTo(x1 + w1, y1 + h1, x1 + w1 - rx1, y1 + h1);
              ctx.lineTo(x1 + rx1, y1 + h1);
              ctx.quadraticCurveTo(x1, y1 + h1, x1, y1 + h1 - rx1);
              ctx.lineTo(x1, y1 + rx1);
              ctx.quadraticCurveTo(x1, y1, x1 + rx1, y1);
              ctx.closePath();
            } else {
              // ÌïòÌä∏ Ïã§Ï†ú SVG path Ï†ÅÏö© (Ï†ïÏ§ëÏïô, Îã§Ïö¥Î°úÎìú)
              const s = (outerSize * 2) / 226.78;
              const ox = cx - 113.39 * s;
              const oy = cy - 104.9 * s;
              ctx.moveTo(144.75*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(135*s+ox, 22.9*s+oy, 125.77*s+ox, 25.29*s+oy, 117.43*s+ox, 28.89*s+oy);
              ctx.bezierCurveTo(117.06*s+ox, 32.57*s+oy, 116.94*s+ox, 40.93*s+oy, 116.82*s+ox, 42.11*s+oy);
              ctx.bezierCurveTo(116.67*s+ox, 43.58*s+oy, 115.08*s+ox, 45.55*s+oy, 113.27*s+ox, 45.59*s+oy);
              ctx.bezierCurveTo(111.46*s+ox, 45.63*s+oy, 110.44*s+ox, 43.02*s+oy, 110.21*s+ox, 42.04*s+oy);
              ctx.bezierCurveTo(109.98*s+ox, 41.06*s+oy, 109.87*s+ox, 34.03*s+oy, 109.68*s+ox, 30.36*s+oy);
              ctx.bezierCurveTo(109.65*s+ox, 29.81*s+oy, 109.57*s+ox, 29.29*s+oy, 109.46*s+ox, 28.79*s+oy);
              ctx.bezierCurveTo(101.18*s+ox, 25.25*s+oy, 92.05*s+ox, 22.89*s+oy, 82.39*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(46.38*s+ox, 18.15*s+oy, 14.36*s+ox, 50.23*s+oy, 14.36*s+ox, 87.81*s+oy);
              ctx.bezierCurveTo(14.36*s+ox, 98.94*s+oy, 17.05*s+ox, 109.44*s+oy, 21.79*s+ox, 118.72*s+oy);
              ctx.bezierCurveTo(26.75*s+ox, 130.58*s+oy, 44.94*s+ox, 167.38*s+oy, 74.45*s+ox, 186.87*s+oy);
              ctx.bezierCurveTo(108.62*s+ox, 209.43*s+oy, 126.46*s+ox, 205.62*s+oy, 152.91*s+ox, 187.32*s+oy);
              ctx.bezierCurveTo(177.88*s+ox, 170.05*s+oy, 201.23*s+ox, 133.54*s+oy, 206.82*s+ox, 115.63*s+oy);
              ctx.bezierCurveTo(210.64*s+ox, 107.13*s+oy, 212.78*s+ox, 97.72*s+oy, 212.78*s+ox, 87.8*s+oy);
              ctx.bezierCurveTo(212.78*s+ox, 50.23*s+oy, 180.76*s+ox, 18.15*s+oy, 144.75*s+ox, 21.89*s+oy);
              ctx.closePath();
            }
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (selectedSize.type === 'circle') {
              ctx.arc(cx, cy, outerSize, 0, Math.PI * 2);
            } else if (selectedSize.type === 'square') {
              const s = (outerSize * 2) / 200;
              const ox = cx - 100 * s;
              const oy = cy - 100 * s;
              
              const x1 = 13.54 * s + ox;
              const y1 = 13.22 * s + oy;
              const w1 = 172.91 * s;
              const h1 = 172.91 * s;
              const rx1 = 28.35 * s;
              
              ctx.moveTo(x1 + rx1, y1);
              ctx.lineTo(x1 + w1 - rx1, y1);
              ctx.quadraticCurveTo(x1 + w1, y1, x1 + w1, y1 + rx1);
              ctx.lineTo(x1 + w1, y1 + h1 - rx1);
              ctx.quadraticCurveTo(x1 + w1, y1 + h1, x1 + w1 - rx1, y1 + h1);
              ctx.lineTo(x1 + rx1, y1 + h1);
              ctx.quadraticCurveTo(x1, y1 + h1, x1, y1 + h1 - rx1);
              ctx.lineTo(x1, y1 + rx1);
              ctx.quadraticCurveTo(x1, y1, x1 + rx1, y1);
              ctx.closePath();
            } else {
              const s = (outerSize * 2) / 226.78;
              const ox = cx - 113.39 * s;
              const oy = cy - 104.9 * s;
              ctx.moveTo(144.75*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(135*s+ox, 22.9*s+oy, 125.77*s+ox, 25.29*s+oy, 117.43*s+ox, 28.89*s+oy);
              ctx.bezierCurveTo(117.06*s+ox, 32.57*s+oy, 116.94*s+ox, 40.93*s+oy, 116.82*s+ox, 42.11*s+oy);
              ctx.bezierCurveTo(116.67*s+ox, 43.58*s+oy, 115.08*s+ox, 45.55*s+oy, 113.27*s+ox, 45.59*s+oy);
              ctx.bezierCurveTo(111.46*s+ox, 45.63*s+oy, 110.44*s+ox, 43.02*s+oy, 110.21*s+ox, 42.04*s+oy);
              ctx.bezierCurveTo(109.98*s+ox, 41.06*s+oy, 109.87*s+ox, 34.03*s+oy, 109.68*s+ox, 30.36*s+oy);
              ctx.bezierCurveTo(109.65*s+ox, 29.81*s+oy, 109.57*s+ox, 29.29*s+oy, 109.46*s+ox, 28.79*s+oy);
              ctx.bezierCurveTo(101.18*s+ox, 25.25*s+oy, 92.05*s+ox, 22.89*s+oy, 82.39*s+ox, 21.89*s+oy);
              ctx.bezierCurveTo(46.38*s+ox, 18.15*s+oy, 14.36*s+ox, 50.23*s+oy, 14.36*s+ox, 87.81*s+oy);
              ctx.bezierCurveTo(14.36*s+ox, 98.94*s+oy, 17.05*s+ox, 109.44*s+oy, 21.79*s+ox, 118.72*s+oy);
              ctx.bezierCurveTo(26.75*s+ox, 130.58*s+oy, 44.94*s+ox, 167.38*s+oy, 74.45*s+ox, 186.87*s+oy);
              ctx.bezierCurveTo(108.62*s+ox, 209.43*s+oy, 126.46*s+ox, 205.62*s+oy, 152.91*s+ox, 187.32*s+oy);
              ctx.bezierCurveTo(177.88*s+ox, 170.05*s+oy, 201.23*s+ox, 133.54*s+oy, 206.82*s+ox, 115.63*s+oy);
              ctx.bezierCurveTo(210.64*s+ox, 107.13*s+oy, 212.78*s+ox, 97.72*s+oy, 212.78*s+ox, 87.8*s+oy);
              ctx.bezierCurveTo(212.78*s+ox, 50.23*s+oy, 180.76*s+ox, 18.15*s+oy, 144.75*s+ox, 21.89*s+oy);
              ctx.closePath();
            }
            ctx.stroke();

            // ÏÉÅÎã® ÏÑ† (ÌïòÌä∏Îäî Ï†úÏô∏)
            if (selectedSize.type !== 'heart') {
              ctx.beginPath();
              ctx.moveTo(cx, 0);
              ctx.lineTo(cx, 2 * SCALE_FACTOR);
              ctx.stroke();
            }

            const dataUrl = canvas.toDataURL('image/png');
            if (isMobile) {
              // Î™®Î∞îÏùº: ÏÉà Ï∞ΩÏóêÏÑú Ïó¥Í∏∞
              const newWindow = window.open();
              if (newWindow) {
                newWindow.document.write(`<img src="${dataUrl}" alt="pin-button" style="max-width:100%"/>`);
              } else {
                alert('ÌåùÏóÖÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§. ÌåùÏóÖ ÌóàÏö© ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
              }
            } else {
              // Îç∞Ïä§ÌÅ¨ÌÜ±: Îã§Ïö¥Î°úÎìú
              const a = document.createElement('a');
              a.href = dataUrl;
              a.download = `pin-button-${selectedSize.label}.png`;
              a.click();
            }
          };

          useEffect(() => {
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            return () => {
              document.removeEventListener('mouseup', handleMouseUp);
              document.removeEventListener('mousemove', handleMouseMove);
            };
          }, [isDragging, isResizing, startPos, startTransform, resizeHandle]);

          useEffect(() => {
              if (image) {
                const timer = setTimeout(() => {
                  setIsInitialLoad(false);
                }, 500);
                return () => clearTimeout(timer);
              }
            }, [image]);

          useEffect(() => {
            const container = document.querySelector('.touch-container');
            if (!container) return;

            let touchStartDist = 0;
            let touchStartTransform = { width: 0, height: 0 };
            let isTouching = false;

            const onTouchStart = (e) => {
              if (!image) return;
              
              if (e.touches.length === 1) {
                isTouching = true;
                const touch = e.touches[0];
                setStartPos({ 
                  x: touch.clientX - transform.x, 
                  y: touch.clientY - transform.y,
                  type: 'drag'
                });
              } else if (e.touches.length === 2) {
                e.preventDefault();
                isTouching = false;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                touchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                touchStartTransform = { width: transform.width, height: transform.height };
              }
            };

            const onTouchMove = (e) => {
              if (!image) return;
              
              if (e.touches.length === 1 && isTouching) {
                e.preventDefault();
                const touch = e.touches[0];
                setTransform(prev => ({ 
                  ...prev, 
                  x: touch.clientX - startPos.x, 
                  y: touch.clientY - startPos.y 
                }));
              } else if (e.touches.length === 2) {
                e.preventDefault();
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                const scale = dist / touchStartDist;
                
                setTransform(prev => ({ 
                  ...prev,
                  width: touchStartTransform.width * scale, 
                  height: touchStartTransform.height * scale 
                }));
              }
            };

            const onTouchEnd = () => {
              isTouching = false;
            };

            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onTouchEnd);

            return () => {
              container.removeEventListener('touchstart', onTouchStart);
              container.removeEventListener('touchmove', onTouchMove);
              container.removeEventListener('touchend', onTouchEnd);
            };
          }, [image, transform, startPos]);

          const size = selectedSize.outer * 3;
          const innerSize = selectedSize.inner * 3;

          const Shape = () => {
            const common = { display: 'block', touchAction: 'none', userSelect: 'none' };
            const clipId = 'clip';
            
            if (selectedSize.type === 'circle') {
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><circle cx={size} cy={size} r={size} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2} 
                    width={transform.width} height={transform.height} preserveAspectRatio="none" clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}}/></>}
                  <circle cx={size} cy={size} r={size} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <circle cx={size} cy={size} r={innerSize} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else if (selectedSize.type === 'square') {
              const r = size * 0.15, ir = innerSize * 0.15;
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><rect x={0} y={0} width={size * 2} height={size * 2} rx={r} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} preserveAspectRatio="none" clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}} /></>}
                  <rect x={0} y={0} width={size * 2} height={size * 2} rx={r} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}} />
                  <rect x={size - innerSize} y={size - innerSize} width={innerSize * 2} height={innerSize * 2} rx={ir} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <line x1={size} y1={0} x2={size} y2={6} stroke="#000" strokeWidth="1" />
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            } else {
              // ÌïòÌä∏ pathÎ•º Ïã§Ï†ú SVG Í∞íÏúºÎ°ú Î≥ÄÌôò (Ï†ïÏ§ëÏïô Î∞∞Ïπò)
              const scale = (size * 2) / 226.78;
              const centerX = size;
              const centerY = size;
              const svgCenterX = 113.39;
              const svgCenterY = 104.9; // ÌïòÌä∏ SVGÏùò Ïã§Ï†ú Ï§ëÏã¨Ï†ê
              const offsetX = centerX - svgCenterX * scale;
              const offsetY = centerY - svgCenterY * scale;
              
              const outerPath = `M${144.75*scale+offsetX},${21.89*scale+offsetY}c${-9.75*scale},${1.01*scale},${-18.98*scale},${3.4*scale},${-27.32*scale},${7*scale},${-0.37*scale},${3.68*scale},${-0.49*scale},${12.04*scale},${-0.61*scale},${13.22*scale},${-0.15*scale},${1.47*scale},${-1.74*scale},${3.44*scale},${-3.55*scale},${3.48*scale},${-1.81*scale},${0.04*scale},${-2.83*scale},${-2.57*scale},${-3.06*scale},${-3.55*scale},${-0.23*scale},${-0.98*scale},${-0.34*scale},${-8.01*scale},${-0.53*scale},${-11.68*scale},${-0.03*scale},${-0.55*scale},${-0.11*scale},${-1.07*scale},${-0.22*scale},${-1.57*scale},${-8.28*scale},${-3.54*scale},${-17.41*scale},${-5.9*scale},${-27.07*scale},${-6.9*scale}C${46.38*scale+offsetX},${18.15*scale+offsetY},${14.36*scale+offsetX},${50.23*scale+offsetY},${14.36*scale+offsetX},${87.81*scale+offsetY}c0,${11.13*scale},${2.69*scale},${21.63*scale},${7.43*scale},${30.91*scale},${4.96*scale},${11.86*scale},${23.15*scale},${48.66*scale},${52.66*scale},${68.15*scale},${34.17*scale},${22.56*scale},${52.01*scale},${18.75*scale},${78.46*scale},${0.45*scale},${24.97*scale},${-17.27*scale},${48.32*scale},${-53.78*scale},${53.91*scale},${-71.69*scale},${3.82*scale},${-8.5*scale},${5.96*scale},${-17.91*scale},${5.96*scale},${-27.83*scale},0,${-37.57*scale},${-32.02*scale},${-69.65*scale},${-68.03*scale},${-65.91*scale}Z`;
              
              const innerPath = `M${141.65*scale+offsetX},${42.21*scale+offsetY}c${-6.25*scale},${0.65*scale},${-16.7*scale},${4.38*scale},${-23.22*scale},${7.08*scale},${-1.33*scale},${0.55*scale},${-2.75*scale},${0.87*scale},${-4.83*scale},${0.96*scale},${-2.15*scale},${-0.09*scale},${-3.56*scale},${-0.41*scale},${-4.89*scale},${-0.96*scale},${-6.51*scale},${-2.7*scale},${-16.97*scale},${-6.44*scale},${-23.22*scale},${-7.08*scale},${-26.23*scale},${-2.72*scale},${-48.86*scale},${17.43*scale},${-48.86*scale},${44.81*scale},0,${12.39*scale},${5.63*scale},${24.2*scale},${8.41*scale},${30.39*scale},${5.35*scale},${14.16*scale},${20.67*scale},${33.47*scale},${37.63*scale},${47.67*scale},${14.76*scale},${12.36*scale},${23.17*scale},${17.05*scale},${30.93*scale},${17*scale}h0s0,0,0,0c0,0,0,0,0,0h0c${7.69*scale},${0.05*scale},${16.1*scale},${-4.64*scale},${30.87*scale},${-17*scale},${16.96*scale},${-14.2*scale},${32.28*scale},${-33.52*scale},${37.63*scale},${-47.67*scale},${2.78*scale},${-6.19*scale},${8.41*scale},${-18*scale},${8.41*scale},${-30.39*scale},0,${-27.37*scale},${-22.63*scale},${-47.53*scale},${-48.86*scale},${-44.81*scale}Z`;
              
              return (
                <svg width={size * 2} height={size * 2 + 6} style={common} className={isInitialLoad ? "fade-in" : ""}>
                  {image && <><defs><clipPath id={clipId}><path d={outerPath} /></clipPath></defs>
                  <image href={image} x={size + transform.x - transform.width / 2} y={size + transform.y - transform.height / 2}
                    width={transform.width} height={transform.height} preserveAspectRatio="none" clipPath={`url(#${clipId})`} pointerEvents="none" style={{transition: 'all 0.1s ease'}}/></>}
                  <path d={outerPath} fill="none" stroke="#000" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  <path d={innerPath} fill="none" stroke="#f00" strokeWidth="2" style={{transition: 'all 0.3s ease'}}/>
                  {!image && <g onClick={() => fileInputRef.current?.click()} style={{cursor:'pointer'}} className="slide-in">
                    <circle cx={size} cy={size} r={30} fill="#f3f4f6" />
                    <text x={size} y={size + 5} textAnchor="middle" fontSize="32" fill="#6b7280" pointerEvents="none">+</text></g>}
                </svg>
              );
            }
          };

          return (
            <div className={`flex ${isMobile ? 'flex-col' : ''} h-screen bg-gray-100`}>
              <div className={`${isMobile ? 'flex-1 order-2' : 'flex-1'} flex items-center justify-center p-4 overflow-auto`}>
              <div className={`relative bg-white rounded-lg shadow-lg p-12 touch-container ${isInitialLoad ? "fade-in" : ""}`}
                onDrop={(e) => { e.preventDefault(); loadImage(e.dataTransfer.files[0]); }} 
                onDragOver={(e) => e.preventDefault()} 
                onMouseDown={handleMouseDown}
                style={{ touchAction: 'none' }}>
                  <div style={{ position: 'relative' }}>
                    <Shape />
                    {image && ['tl','tr','bl','br','t','b','l','r'].map(h => {
                      const cursors = {tl:'nwse-resize',tr:'nesw-resize',bl:'nesw-resize',br:'nwse-resize',t:'ns-resize',b:'ns-resize',l:'ew-resize',r:'ew-resize'};
                      const isCorner = ['tl','tr','bl','br'].includes(h);
                      const pos = {
                        tl: [transform.x - transform.width / 2, transform.y - transform.height / 2],
                        tr: [transform.x + transform.width / 2, transform.y - transform.height / 2],
                        bl: [transform.x - transform.width / 2, transform.y + transform.height / 2],
                        br: [transform.x + transform.width / 2, transform.y + transform.height / 2],
                        t: [transform.x, transform.y - transform.height / 2],
                        b: [transform.x, transform.y + transform.height / 2],
                        l: [transform.x - transform.width / 2, transform.y],
                        r: [transform.x + transform.width / 2, transform.y]
                      };
                      return <div key={h} 
                        className={`transform-handle ${isCorner ? 'corner' : 'edge'}`}
                        style={{ left: size + pos[h][0], top: size + pos[h][1], cursor: cursors[h] }} 
                        onMouseDown={(e) => handleResizeStart(e, h)}
                        onTouchStart={(e) => handleTouchResizeStart(e, h)} />;
                    })}
                  </div>
                </div>
              </div>

              <div className={`${isMobile ? 'order-1 w-full' : 'w-48'} bg-white shadow-lg ${isMobile ? 'p-2' : 'p-4'} flex ${isMobile ? 'flex-row flex-wrap' : 'flex-col'} ${isMobile ? 'gap-1' : 'gap-3'} overflow-auto`}>
                <h2 className={`${isMobile ? 'w-full text-sm' : 'text-lg'} font-bold ${isMobile ? 'mb-1' : 'mb-2'}`}>Ïä§ÌäúÎîîÏò§ Î≥¥Îùº</h2>
                
                {!isMobile ? SIZES.map((s, i) => (
                  <button key={i} onClick={() => { setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 }); }}
                    className={`px-4 py-2 rounded-lg text-sm font-medium text-left ${selectedSize.label === s.label ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'} btn-hover`}>
                    {s.label}
                  </button>
                )) : (
                  <select value={selectedSize.label} onChange={(e) => {
                    const s = SIZES.find(sz => sz.label === e.target.value);
                    setSelectedSize(s); setImage(null); setTransform({ x: 0, y: 0, width: 0, height: 0 });
                  }} className="flex-1 px-2 py-1.5 rounded text-xs bg-blue-500 text-white font-medium">
                    {SIZES.map((s, i) => <option key={i} value={s.label}>{s.label}</option>)}
                  </select>
                )}

                <button onClick={() => fileInputRef.current?.click()}
                  className={`${isMobile ? 'flex-1 px-2 py-1.5 text-xs' : 'mt-4 px-4 py-2 text-sm'} flex items-center justify-center gap-1 bg-green-500 text-white rounded hover:bg-green-600`}>
                  ‚¨Ü {isMobile ? 'ÏóÖÎ°úÎìú' : 'ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú'}
                </button>

                {image && (
                  <>
                    <div className={`flex ${isMobile ? 'gap-1 w-1/2' : 'gap-2'}`}>
                      <button onClick={() => zoom(0.9)} className={`flex-1 bg-gray-500 text-white rounded hover:bg-gray-600 ${isMobile ? 'px-2 py-1 text-base' : 'px-3 py-2 text-lg'}`}>‚àí</button>
                      <button onClick={() => zoom(1.1)} className={`flex-1 bg-gray-500 text-white rounded hover:bg-gray-600 ${isMobile ? 'px-2 py-1 text-base' : 'px-3 py-2 text-lg'}`}>+</button>
                    </div>
                    
                    <div className={`${isMobile ? 'w-1/2' : ''} text-center bg-gray-100 rounded ${isMobile ? 'py-1' : 'py-2'}`}>
                      <span className={`font-medium text-gray-700 ${isMobile ? 'text-xs' : 'text-sm'}`}>
                        {getZoomPercentage()}%
                      </span>
                    </div>

                    <div className={`${isMobile ? 'w-full' : ''}`}>
                      <div className={`grid grid-cols-3 ${isMobile ? 'gap-0.5' : 'gap-1'}`}>
                        <div></div>
                        <button onClick={() => moveImage(0, -10)} className={`bg-purple-500 text-white rounded hover:bg-purple-600 ${isMobile ? 'px-2 py-1 text-sm' : 'px-3 py-2'}`}>‚Üë</button>
                        <div></div>
                        <button onClick={() => moveImage(-10, 0)} className={`bg-purple-500 text-white rounded hover:bg-purple-600 ${isMobile ? 'px-2 py-1 text-sm' : 'px-3 py-2'}`}>‚Üê</button>
                        <div></div>
                        <button onClick={() => moveImage(10, 0)} className={`bg-purple-500 text-white rounded hover:bg-purple-600 ${isMobile ? 'px-2 py-1 text-sm' : 'px-3 py-2'}`}>‚Üí</button>
                        <div></div>
                        <button onClick={() => moveImage(0, 10)} className={`bg-purple-500 text-white rounded hover:bg-purple-600 ${isMobile ? 'px-2 py-1 text-sm' : 'px-3 py-2'}`}>‚Üì</button>
                        <div></div>
                      </div>
                    </div>
                  </>
                )}

                {image && (
                  <button onClick={resetImage}
                    className={`${isMobile ? 'w-full px-2 py-1.5 text-xs' : 'px-4 py-2 text-sm'} flex items-center justify-center gap-1 bg-orange-500 text-white rounded hover:bg-orange-600`}>
                    üîÑ {isMobile ? 'Ï¥àÍ∏∞Ìôî' : 'Ïù¥ÎØ∏ÏßÄ Ï¥àÍ∏∞Ìôî'}
                  </button>
                )}

                <button onClick={downloadImage} disabled={!image}
                  className={`${isMobile ? 'w-full px-2 py-1.5 text-xs' : 'px-4 py-2 text-sm'} flex items-center justify-center gap-1 rounded ${image ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500'}`}>
                  ‚¨á {isMobile ? 'Îã§Ïö¥' : 'PNG Îã§Ïö¥Î°úÎìú'}
                </button>

                {image && !isMobile && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg text-xs text-gray-700">
                    <p className="font-bold mb-1">ÏÇ¨Ïö©Î≤ï:</p>
                    <p>‚Ä¢ ÎìúÎûòÍ∑∏: Ïù¥Îèô</p>
                    <p>‚Ä¢ Ìï∏Îì§: ÌÅ¨Í∏∞Ï°∞Ï†à</p>
                    <p>‚Ä¢ +/- : ÌôïÎåÄÏ∂ïÏÜå</p>
                    <p>‚Ä¢ ÌôîÏÇ¥Ìëú: ÎØ∏ÏÑ∏Ï°∞Ï†ï</p>
                  </div>
                )}
              </div>

              <input ref={fileInputRef} type="file" accept="image/*" onChange={(e) => e.target.files && loadImage(e.target.files[0])} className="hidden" />
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>